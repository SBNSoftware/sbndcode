########################################################################
# This script is shell-agnostic, which involves much acrobatics to avoid
# causing errors in one interpreter or another (*stares in csh*).
#
# There should be as little as possible here, with most of the heavy
# lifting done by other small scripts.
#
# When sourcing this file from a script, you may have to tell this
# source file where it is via the fw_db shell (or env) variable, i.e.
#    set fw_db=/some/path; source /some/path/this_file
# or  fw_db=/some/path; . /some/path/this_file
#
# Generated by cetmodules 3.20.00 at Thu Oct 13 17:05:42 CDT 2022
########################################################################

########################################################################
# NO USER-SERVICEABLE PARTS BELOW.
########################################################################

# Determine shell flavor.
true && test $?shell = 1 && set _cetpkg_shell_flavor=csh || _cetpkg_shell_flavor=sh

####################################
# A common set of commands to use to hide as many shell flavor
# differences as possible.

##################
# IMPORTANT NOTE:
#
# Following extensive tests in multiple shells, I have reached the
# conclusion that it is not actually possible for a function to mirror
# the semantics of an assignment with respect to the status code of ``
# and compound statements joined with "||" or "&&". To handle this, we
# write a large chunk of shell code to a temporary file in the current
# directory a.k.a. CETPKG_BUILD with shell variable assignments correct
# according to the shell flavor, and then source it. This also allows us
# to deal with the fact that some shells don't pass arguments to sourced
# scripts *stares harder in csh*.
#
# 2020-06-24 CHG.
##################

# If we're C-flavored, set up the commands using alias.
test "$_cetpkg_shell_flavor" = csh && \
  set _cetpkg_nobuild="" && \
  set _cetpkg_shell_var_set=set\\1 && \
  set _cetpkg_to_stderr="| sh -c 'cat 1>\\&2'" && \
  alias vecho_ 'if ($?vv == 1) echo \>\> \!*' && \
  alias unsetenv_ unsetenv && \
  alias tnotnull "eval '"'test $?'"\!* -eq 1' && eval '"'test -n "$'"\!*"'"'"'" && \
  alias nullout "\!* >& /dev/null" && \
  alias __TOP_EOF__ '' && \
  alias return exit

# For Bourne-flavored shells, use functions.
test "$_cetpkg_shell_flavor" = sh && \
  _cetpkg_nobuild="" && \
  _cetpkg_shell_var_set= && \
  _cetpkg_to_stderr='1>\&2' && \
  eval 'vecho_() { test -n "${vv-}" && echo ">> $*"; return 0; }' && \
  eval 'setenv() { eval "$1=\"\${2-}\"; export $1"; }' && \
  eval 'unsetenv_() { unset "$@"; }' && \
  eval 'source() { . "$@"; }' && \
  eval 'tnotnull() { eval "test -n \"\${$1-}\""; }' && \
  eval 'nullout() { "$@" >/dev/null 2>&1; }'
####################################

##################
# Check for UPS (uses alias for return in C-flavored shells).
test -z "$UPS_DIR" && \
  ( echo ""; echo "ERROR: you MUST set up UPS"; echo "" ) && \
  return 1 || true
##################

####################################
# Need to find ourselves to set CETPKG_SOURCE.

# Define empty variables for C-flavor shells to make things easier.
test "$_cetpkg_shell_flavor" = csh && \
  set _cetpkg_fw_db= _cetpkg_myself= _cetpkg_mydir=

# If user has set fw_db, identify our top-level source directory now.
test "$_cetpkg_shell_flavor" = csh && tnotnull fw_db && \
  set _cetpkg_fw_db=`sh -c "cd $fw_db:q >/dev/null 2>&1 && /bin/pwd -P"` && \
  vecho_ "found ourselves through fw_db" || true
test "$_cetpkg_shell_flavor" = sh && tnotnull fw_db && \
  _cetpkg_fw_db=`sh -c "cd \"$fw_db\" >/dev/null 2>&1 && /bin/pwd -P"` && \
  vecho_ "found ourselves through fw_db" || true

##################
# For Bash and zsh, identify ourselves now so we don't have to go
# through acrobatics later in the sourced script.
test "$_cetpkg_shell_flavor" = sh && tnotnull BASH_SOURCE && \
  _cetpkg_myself="$BASH_SOURCE" && test -n "$BASH_SOURCE" && \
  vecho_ "found ourselves through BASH_SOURCE" || true
test "$_cetpkg_shell_flavor" = sh -a -z "$_cetpkg_myself" && \
  tnotnull ZSH_VERSION && eval '_cetpkg_myself="${(%):-%x}"' && \
  test -n "$_cetpkg_myself" && \
  vecho_ "found ourselves through ZSH prompt logic" || true
test "$_cetpkg_shell_flavor" = sh && tnotnull _cetpkg_myself && \
  _cetpkg_mydir=`dirname "$_cetpkg_myself"` && \
  _cetpkg_fw_db=`sh -c "cd $_cetpkg_mydir >/dev/null 2>&1 && /bin/pwd -P"` || true
##################

##################
# History is applicable only for interactive t/csh.
test -z "$_cetpkg_fw_db" -a "$_cetpkg_shell_flavor" = csh -a $?history = 0 && \
  set history=5  || true
test -z "$_cetpkg_fw_db" -a "$_cetpkg_shell_flavor" = csh && \
  set _cetpkg_mydir=`history 1|sed -Ee 's/^[[:space:][:digit:]:]*.*\bsource[[:space:]]+//'` && \
  test -n "$_cetpkg_mydir" && set _cetpkg_mydir=`dirname $_cetpkg_mydir[1]:q` && \
  set _cetpkg_fw_db=`sh -c "cd $_cetpkg_mydir:q >/dev/null 2>&1 && /bin/pwd -P"` && \
  vecho_ 'setting db via interactive history' || true
##################

# Set CETPKG_SOURCE.
test -n "$_cetpkg_fw_db" && \
  vecho_ "_cetpkg_fw_db=$_cetpkg_fw_db" && \
  setenv CETPKG_SOURCE `dirname $_cetpkg_fw_db` || \
  printf "WARNING: please set shell or env. variable fw_db (to be the path to the\n\
         framework source code). Fix this and other errors may go away.\n"
####################################

##################
# Set CETPKG_BUILD.
setenv CETPKG_BUILD `/bin/pwd -P`
##################

########################################################################
# Write the rest of ourselves to a file and source it to handle status
# code semantics for variable assignments.
#
# Note that even here we have to play a trick or two due to the fact
# that we have to deal with the difference in the way sh- and csh-flavor
# shells handle a quoted delimiter word for a HERE document: the latter
# expect the delimiter to include the quoting; the former do not. This
# is the reason for the C-flavored __TOP_EOF__ alias, and the explicit
# return at the end of the sourced script.
#
########################################################################

sed -Ee 's&(^|[^[:alnum:]_])__SET__([[:space:]]+)&'$_cetpkg_shell_var_set'&g' \
  -e 's&__SETUP_ARGS__&'"$*"'&g' \
  -e 's&__TO_STDERR__&'"$_cetpkg_to_stderr"'&g' \
  > ./setup_common.$_cetpkg_shell_flavor <<\__TOP_EOF__
########################################################################

####################################
# Personality check: are we setup_deps or setup_for_development?
#
# If we're sourcing setup.in directly (e.g. for cetmodules itself) then
# we select "setup_for_development" behavior, otherwise _cetpkg_nobuild
# will be set appropriately by CMake's CONFIGURE() command for
# setup_for_development or setup_deps.

test -z "$_cetpkg_nobuild" -o "$_cetpkg_nobuild" = "--nobuild" || \
  __SET__ _cetpkg_nobuild="" || true
####################################

####################################
# Initial info.

printf "\n";
test -z "$_cetpkg_nobuild" && \
  echo "The working build directory is $CETPKG_BUILD" || true
cat <<EOF
The source code directory is $CETPKG_SOURCE

---------------------- check this block for errors ---------------------
EOF

__SET__ _cetpkg_status=""
####################################

####################################
# Attempt to find a suitable cetmodules to set up.

__SET__ _cetpkg_cetmsetup=`sed -nE 's&^[[:space:]]*(cetmodules)[[:space:]]+([^[:space:]]+).*\bonly_for_build\b.*$&\1 \2&p' "$CETPKG_SOURCE/ups/product_deps"`
test -z "_cetpkg_cetmsetup" -a ! -x "$CETPKG_SOURCE/libexec/set_dev_products" && \
  __SET__ _cetpkg_status=1 && \
  echo "ERROR: unable to find suitable cetmodules >= 2.00.00" || true
test -n "$_cetpkg_status" -o -z "$_cetpkg_cetmsetup" || setup -B $_cetpkg_cetmsetup
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: setup of $_cetpkg_cetmsetup has failed" || true
test -z "$_cetpkg_status$_cetpkg_cetmsetup" && setenv PATH `dropit -sfe "$CETPKG_SOURCE/bin"` && __SET__ _cetpkg_cettop="$CETPKG_SOURCE" || true
test -z "$_cetpkg_status$_cetpkg_cettop" -a -n "$CETMODULES_DIR" && __SET__ _cetpkg_cettop="$CETMODULES_DIR"
####################################

########################################################################
# A bootstrapped Perl environment is only needed if we're building
# cetmodules itself.

test -n "$_cetpkg_status" || test -n "$CETMODULES_DIR" || \
  setup cetpkgsupport
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: setup of cetpkgsupport has failed" || true
test -n "$_cetpkg_status" || test -n "$CETMODULES_DIR" || \
  "$_cetpkg_cettop/libexec/bootstrap-perl-env" > \
  "$CETPKG_BUILD/bootstrap.log"
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: bootstrap of Perl environment for cetmodules has failed: see $CETPKG_BUILD/bootstrap.log" || true
test -n "$_cetpkg_status" || test -n "$CETMODULES_DIR" || \
  eval "`perl -I\"$CETPKG_BUILD/$CET_SUBDIR/CPAN/lib/perl5\" -Mlocal::lib=\"$CETPKG_BUILD/$CET_SUBDIR/CPAN\",\"$CETPKG_BUILD/$CET_SUBDIR/cpan_build\"\`test \$?shell = 1 && printf \",--shelltype=csh\"\``"
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: setup of Perl environment for cetmodules has failed" || true

####################################
# Generate the setup script to set up dependencies.

test -n "$_cetpkg_status" || \
  __SET__ _cetpkg_setup="`${_cetpkg_cettop}/libexec/set_dev_products $_cetpkg_nobuild __SETUP_ARGS__`"
test $? != 0 -o -z "$_cetpkg_setup" && __SET__ _cetpkg_status=1 && \
  echo "ERROR: generation of setup script has failed" || true
####################################

####################################
# Source the setup script to set up dependencies.

test -n "$_cetpkg_status" || source "$_cetpkg_setup"
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: setup of required products has failed" || true
__SET__ _cetpkg_setup_errlog="$CETPKG_BUILD/cetpkg_setup.err"
test -s "$_cetpkg_setup_errlog" && cat "$_cetpkg_setup_errlog" || \
  rm -f "$_cetpkg_setup_errlog"
####################################

cat <<EOF
------------------------------------------------------------------------

EOF

# Final sanity check and report.
test -n "$_cetpkg_status" -o -n "$_cetpkg_nobuild" || \
  "$_cetpkg_cettop/libexec/verify_build_environment" "$CETPKG_BUILD"
test $? != 0 && __SET__ _cetpkg_status=1 && \
  echo "ERROR: unable to verify build environment" || true

####################################
# Clean up before exiting.

# Clean up C-flavor aliases and prepare to return^H^H^H^H^H^Hexit.
test "$_cetpkg_shell_flavor" = csh && \
  unalias vecho_ unsetenv_ tnotnull nullout __TOP_EOF__ return && \
  set return=exit || return=return

# Finish cleanup and exit. Note the use of eval so we can unset
# everything including $return and $_cetpkg_status.
eval "unset vecho_ setenv unsetenv_ source tnotnull nullout "\
"_cetpkg_nobuild _cetpkg_shell_var_set _cetpkg_to_stderr"\
"_cetpkg_fw_db _cetpkg_myself _cetpkg_mydir _cetpkg_cetmsetup "\
"_cetpkg_cettop _cetpkg_setup _cetpkg_setup_errlog "\
"_cetpkg_shell_flavor return _cetpkg_status; \
$return $_cetpkg_status"
####################################

########################################################################
\__TOP_EOF__
__TOP_EOF__

source ./setup_common.$_cetpkg_shell_flavor
