////////////////////////////////////////////////////////////////////////
// Class:       RecoEfficencyFinder
// Module Type: analyzer
// File:        RecoEfficencyFinder_module.cc
//
// Generated at Thu Sep 19 03:45:10 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

//Framework Includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/FindManyP.h"
//LArSoft Includes 
#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larreco/RecoAlg/MCRecoUtils/RecoUtils.h"
#include "larreco/RecoAlg/MCRecoUtils/ShowerUtils.h"
#include "larcorealg/Geometry/BoxBoundedGeo.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larcoreobj/SummaryData/POTSummary.h"  
#include "nusimdata/SimulationBase/MCFlux.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

//C++ Includes
#include <vector>
#include <iostream>

//Root Includes
#include "TSystem.h"
#include "TGraph.h"
#include "TF1.h"
#include "TFile.h"

namespace ana {
  class RecoEfficencyFinder;
}

class ana::RecoEfficencyFinder : public art::EDAnalyzer {
public:
  explicit RecoEfficencyFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  RecoEfficencyFinder(RecoEfficencyFinder const &) = delete;
  RecoEfficencyFinder(RecoEfficencyFinder &&) = delete;
  RecoEfficencyFinder & operator = (RecoEfficencyFinder const &) = delete;
  RecoEfficencyFinder & operator = (RecoEfficencyFinder &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void beginSubRun(const art::SubRun& sr) override;
  void endJob() override;
  bool containedInAV(const TVector3 &v);
  bool containedInFV(const TVector3 &v);

  bool isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance=5.) const;
  bool isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, TVector3& position, float distance=5.) const;
  bool isShowerContainedish(const std::vector<int>& shower, std::map<int,float>& Track_Energy_map,std::map<int, const simb::MCParticle*>& trueParticles);
  bool isPrimaryHadron(const int& track, art::Ptr<simb::MCTruth>& mc_truth, std::map<int,const simb::MCParticle*>& trueParticles,int neutrino_iter,std::map<int,float>& Track_Energy_map);
  void OrderShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection);
  void OrderPerpendiuclarShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection);

  int SpacePointPlane(art::Ptr<recob::SpacePoint> const& sp,
		      art::FindManyP<recob::Hit> const& fmh) const ;
    
  double  TotalCharge(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh);

  double SpacePointCharge(art::Ptr<recob::SpacePoint> const& sp,
			  art::FindManyP<recob::Hit> const& fmh) const;

  double SpacePointTime(art::Ptr<recob::SpacePoint> const& sp,
			art::FindManyP<recob::Hit> const& fmh) const;
    

  double SpacePointProjection(const art::Ptr<recob::SpacePoint>&sp,
			      TVector3 const& vertex, 
			      TVector3 const& direction) const; 

  double ShowerPerpendicularDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerPerpendicularLength, art::FindManyP<recob::Hit> const& fmh);

  double ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, art::FindManyP<recob::Hit> const& fmh);

  double ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, double& OpenAngle, art::FindManyP<recob::Hit> const& fmh);


  TVector3 SpacePointPosition(art::Ptr<recob::SpacePoint> const& sp) const;

  double SignalOscillationWeight(int& initpdg, int& finpdg, float& lOverE) const;
  
  double TotalEnergy(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh);

private:

  //Module Labels
  art::InputTag fShowerModuleLabel;
  art::InputTag fPFParticleLabel;
  art::InputTag fGenieGenModuleLabel;
  art::InputTag fCalorimetryModuleLabel;
  art::InputTag fTrackModuleLabel;
  art::InputTag fLArGeantModuleLabel;

  //Fcl parameters 
  float fMinRecoEnergyCut;
  float fNSegments;
  std::vector<geo::BoxBoundedGeo> fActiveVolume; //!< List of active volumes
  std::vector<geo::BoxBoundedGeo> fFiducalVolume;
  double fdmsq;
  double fsinsq2thmumu;
  double fsinsq2thmue;

  double fOscDimensFactor = 1.26693281; // Dimensional factor (GeV/eV^2/km) appearing in netrino oscillation formula;

  std::vector<double> fConversion = {0.00155644,0.00173915,0.00153631};
  

  //services
  detinfo::DetectorProperties const* fDetProp;
  art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  art::ServiceHandle<art::TFileService> tfs;

  //Branches
  std::vector<float> number_of_showers_per_neutrino;
  std::vector<float> vertex_recoKE_branch;
  std::vector<float> vertex_trueKE_branch;
  std::vector<float> vertex_reco_branch;
  std::vector<float> nu_reco_energy_branch;
  std::vector<float> nu_truth_energy_branch;
  std::vector<float> nu_interaction_type_branch;
  std::vector<float> nu_mode_branch;
  std::vector<float> nu_E_branch;
  std::vector<float> nu_E_numtrue_branch;
  std::vector<float> nu_distance_branch;
  std::vector<float> nu_osc_prob_branch;
  std::vector<float> nu_pdg_branch;
  std::vector<float> in_FV_branch;
  std::vector<std::vector<float> > truepionE_branch;
  std::vector<std::vector<float> > trueprotonE_branch;
  std::vector<std::vector<float> > truekaonE_branch;
  std::vector<std::vector<float> > truetrackE_branch;
  std::vector<std::vector<float> > shower_energy_branch;
  std::vector<std::vector<float> > truth_pid_branch;
  std::vector<std::vector<float> > true_energy_branch;
  std::vector<std::vector<float> > shower_coversion_gap_branch;
  std::vector<std::vector<float> > shower_residual_dist_branch;
  std::vector<std::vector<float> > shower_len_branch;
  std::vector<std::vector<float> > shower_length_branch;
  std::vector<std::vector<float> > shower_density_branch;
  std::vector<std::vector<float> > shower_length_perp_branch;
  std::vector<std::vector<float> > shower_density_perp_branch;
  std::vector<std::vector<float> > shower_density_3D_branch;
  std::vector<std::vector<float> > shower_density_grad_perp_branch;
  std::vector<std::vector<float> > shower_density_grad_branch;
  std::vector<std::vector<float> > shower_density_ratio_branch;
  std::vector<std::vector<float> > shower_density_grad_ratio_branch;
  std::vector<std::vector<float> > shower_density_grad_perp_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_ratio_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_new_branch;
  std::vector<std::vector<float> > shower_open_angle_branch;

  std::vector<std::vector<float> > shower_dEdx_branch;
  std::vector<std::vector<float> > track_lengths_branch;

  std::vector<std::vector<float> > track_E_branch;
  std::vector<std::vector<float> > track_trueE_branch;
  std::vector<std::vector<float> > track_pdg_branch; 
  std::vector<std::vector<float> > track_resE_branch;
  
  float trueShower_num_branch;
  float numtrueVtx_branch;

  float POT;

  //TTree
  TTree* Tree;
  TTree* POTTree;

  TGraph* SegmentDensityPerpGraph;
  TGraph* SegmentDensityGraph;


  int num_v_recoed;

  std::vector<double> SegmentDensityPerpFinal;
  std::vector<double> SegmentDensityFinal;
  std::vector<double> SegmentDensityFinalN;
  std::vector<double> SegmentDensityPerpFinalN;
  double Nfinal;

  TFile* file = new TFile("test.root","RECREATE");

};


ana::RecoEfficencyFinder::RecoEfficencyFinder(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset),
  fShowerModuleLabel     (pset.get<art::InputTag>("ShowerModuleLabel")),
  fPFParticleLabel       (pset.get<art::InputTag>("PFParticleLabel")),
  fGenieGenModuleLabel   (pset.get<art::InputTag>("GenieGenModuleLabel")),
  fCalorimetryModuleLabel(pset.get<art::InputTag>("CalorimetryModuleLabel")),
  fTrackModuleLabel      (pset.get<art::InputTag>("TrackModuleLabel")),
  fLArGeantModuleLabel   (pset.get<art::InputTag>("LArGeantModuleLabel")),
  fMinRecoEnergyCut      (pset.get<float>        ("MinRecoEnergyCut")),
  fNSegments             (pset.get<float>        ("NSegments")),
  fdmsq                  (pset.get<float>        ("dmsq")),
  fsinsq2thmumu          (pset.get<float>        ("sinsq2thmumu")),   
  fsinsq2thmue           (pset.get<float>        ("sinsq2thmue")),
  fDetProp(lar::providerFrom<detinfo::DetectorPropertiesService>())
{

  SegmentDensityPerpFinal.resize(fNSegments,0);
  SegmentDensityFinal.resize(fNSegments,0);
  SegmentDensityFinalN.resize(fNSegments,0);
  SegmentDensityPerpFinalN.resize(fNSegments,0);

  // setup active volume bounding boxes
  std::vector<fhicl::ParameterSet> AVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("ActiveVolume");
  for (auto const& AV : AVs) {
    double xmin = AV.get<double>("xmin");
    double ymin = AV.get<double>("ymin");
    double zmin = AV.get<double>("zmin");
    double xmax = AV.get<double>("xmax");
    double ymax = AV.get<double>("ymax");
    double zmax = AV.get<double>("zmax");
    fActiveVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }

  std::vector<fhicl::ParameterSet> FVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("FiducalVolume");
  for (auto const& FV : FVs) {
    double xmin = FV.get<double>("xmin");
    double ymin = FV.get<double>("ymin");
    double zmin = FV.get<double>("zmin");
    double xmax = FV.get<double>("xmax");
    double ymax = FV.get<double>("ymax");
    double zmax = FV.get<double>("zmax");
    fFiducalVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }



}

void ana::RecoEfficencyFinder::beginSubRun(const art::SubRun& sr)
{
  art::Handle< sumdata::POTSummary > potListHandle;

  if(sr.getByLabel(fGenieGenModuleLabel,potListHandle))
    POT = potListHandle->totpot;
  
  POTTree->Fill();
}



void ana::RecoEfficencyFinder::beginJob() {

  POTTree = tfs->make<TTree>("RecoEffPOTTree", "Tree Holding POT information");
  POTTree->Branch("POT",&POT,32000,0);
      
  Tree = tfs->make<TTree>("RecoEffMetricTree", "Tree Holding all metric information");
  gInterpreter->GenerateDictionary("vector<vector<float> >","vector");

  SegmentDensityPerpGraph = tfs->makeAndRegister<TGraph>("SegmentDensityPerpGraph","SegmentDensityPerpGraph");
  SegmentDensityGraph = tfs->makeAndRegister<TGraph>("SegmentDensityGraph","SegmentDensityGraph");

  //Initalise the branches
  Tree->Branch("number_of_showers_per_neutrino","std::vector<float>", &number_of_showers_per_neutrino, 32000, 0);
  Tree->Branch("shower_energy","std::vector<std::vector<float> >", &shower_energy_branch, 32000, 0);
  Tree->Branch("truth_pid","std::vector<std::vector<float> >", &truth_pid_branch,32000,0);
  Tree->Branch("true_energy","std::vector<std::vector<float> >",&true_energy_branch,32000,0);
  Tree->Branch("trueShower_num",&trueShower_num_branch,32000,0);
  Tree->Branch("numtrueVtx_branch",&numtrueVtx_branch,32000,0);
  Tree->Branch("vertex_recoK","std::vector<float>",&vertex_recoKE_branch,32000,0);
  Tree->Branch("vertex_trueK","std::vector<float>",&vertex_trueKE_branch,32000,0);

  Tree->Branch("true_trackE","std::vector<std::vector<float>>",&truetrackE_branch,32000,0);
  Tree->Branch("true_pionE","std::vector<std::vector<float>>",&truepionE_branch,32000,0);
  Tree->Branch("true_protonE","std::vector<std::vector<float>>",&trueprotonE_branch,32000,0);
  Tree->Branch("true_kaonE","std::vector<std::vector<float>>",&truekaonE_branch,32000,0);

  Tree->Branch("vertex_reco","std::vector<float>",&vertex_reco_branch,32000,0);
  Tree->Branch("shower_coversion_gap","std::vector<std::vector<float>>",&shower_coversion_gap_branch,32000,0);
  Tree->Branch("shower_residual_dist","std::vector<std::vector<float>>",&shower_residual_dist_branch,32000,0);
  Tree->Branch("shower_len","std::vector<std::vector<float>>",&shower_len_branch,32000,0);
  Tree->Branch("shower_length","std::vector<std::vector<float>>",&shower_length_branch,32000,0);
  Tree->Branch("shower_density","std::vector<std::vector<float>>",&shower_density_branch,32000,0);
  Tree->Branch("shower_length_perp","std::vector<std::vector<float>>",&shower_length_perp_branch,32000,0);
  Tree->Branch("shower_density_perp","std::vector<std::vector<float>>",&shower_density_perp_branch,32000,0);
  Tree->Branch("shower_density_3D","std::vector<std::vector<float>>",&shower_density_3D_branch,32000,0);
  Tree->Branch("shower_density_grad_perp","std::vector<std::vector<float>>",&shower_density_grad_perp_branch,32000,0);
  Tree->Branch("shower_density_grad","std::vector<std::vector<float>>",&shower_density_grad_branch,32000,0);
  Tree->Branch("shower_density_ratio","std::vector<std::vector<float>>",&shower_density_ratio_branch,32000,0);
  Tree->Branch("shower_density_grad_ratio","std::vector<std::vector<float>>",&shower_density_grad_ratio_branch,32000,0);
  Tree->Branch("shower_density_grad_ratio_sq","std::vector<std::vector<float>>",&shower_density_grad_ratio_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_perp_sq","std::vector<std::vector<float>>",&shower_density_grad_perp_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_sq","std::vector<std::vector<float>>",&shower_density_grad_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_new","std::vector<std::vector<float>>",&shower_density_grad_new_branch,32000,0);
  Tree->Branch("shower_open_angle","std::vector<std::vector<float>>",&shower_open_angle_branch,32000,0);

  Tree->Branch("shower_dEdx","std::vector<std::vector<float>>",&shower_dEdx_branch,32000,0);

  Tree->Branch("track_lengths","std::vector<std::vector<float>>",&track_lengths_branch,32000,0);
  Tree->Branch("track_E","std::vector<std::vector<float>>",&track_E_branch,32000,0);
  Tree->Branch("track_trueE","std::vector<std::vector<float>>",&track_trueE_branch,32000,0);
  Tree->Branch("track_pdg","std::vector<std::vector<float>>",&track_pdg_branch,32000,0);
  Tree->Branch("track_resE","std::vector<std::vector<float>>",&track_resE_branch,32000,0);
  Tree->Branch("nu_reco_energy","std::vector<float>",&nu_reco_energy_branch,32000,0);
  Tree->Branch("nu_truth_energy","std::vector<float>",&nu_truth_energy_branch,32000,0);
  Tree->Branch("nu_interaction_type","std::vector<float>",&nu_interaction_type_branch,32000,0);
  Tree->Branch("nu_mode","std::vector<float>",&nu_mode_branch,32000,0);
  Tree->Branch("nu_E","std::vector<float>",&nu_E_branch,32000,0);
  Tree->Branch("nu_E_numtrue","std::vector<float>",&nu_E_numtrue_branch,32000,0);
  
  Tree->Branch("nu_distance","std::vector<float>",&nu_distance_branch,32000,0);
  Tree->Branch("in_FV","std::vector<float>", &in_FV_branch, 32000,0);
  Tree->Branch("nu_osc_prob","std::vector<float>",&nu_osc_prob_branch,32000,0);
  Tree->Branch("nu_pdg","std::vector<float>",&nu_pdg_branch,32000,0);

  num_v_recoed = 0;

 }

void ana::RecoEfficencyFinder::analyze(art::Event const & evt){

  auto const& mcflux = evt.getValidHandle<std::vector<simb::MCFlux> >(fGenieGenModuleLabel);

  //Get the showers 
  art::Handle<std::vector<recob::Shower> > showerListHandle;
  std::vector<art::Ptr<recob::Shower> > showers;
  if(evt.getByLabel(fShowerModuleLabel,showerListHandle)){
    art::fill_ptr_vector(showers,showerListHandle);
  }

  //Get the pf particles 
  art::Handle<std::vector<recob::PFParticle> > pfpHandle;
  std::vector<art::Ptr<recob::PFParticle> > pfps;
  if(evt.getByLabel(fPFParticleLabel,pfpHandle))
    {art::fill_ptr_vector(pfps,pfpHandle);}

  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);

  //Get the tracks
  art::Handle<std::vector<recob::Track> > trackListHandle;
  evt.getByLabel(fTrackModuleLabel,trackListHandle);
  if(!trackListHandle.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track list not valid";
    return;
  }

  //Get the SimChannels so that we can find the IDEs deposited on them.
  art::Handle<std::vector<sim::SimChannel> > simChannelHandle;
  std::vector<art::Ptr<sim::SimChannel> > simchannels;
  if(evt.getByLabel(fLArGeantModuleLabel,simChannelHandle))
  {art::fill_ptr_vector(simchannels, simChannelHandle);}


  //Association between Showers and pfParticle
  art::FindManyP<recob::Shower> fmsh(pfpHandle, evt, fShowerModuleLabel);
  if(!fmsh.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Shower and PF particle association is somehow not valid. Stopping";
    return;
  }
  
  //Assocations between pfparticle and vertex.
  art::FindManyP<recob::Vertex> fmv(pfpHandle, evt, fPFParticleLabel);
  if(!fmv.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Vertex and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Association between Showers and 2d Hits
  art::FindManyP<recob::Hit> fmh(showerListHandle, evt, fShowerModuleLabel);
  if(!fmh.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Hit-Recob::Shower association is somehow not valid. Stopping";
    return;
  }

  //Association between Showers and 2d Hits
  art::FindManyP<recob::SpacePoint> fmsp(showerListHandle, evt, fShowerModuleLabel);
  if(!fmsp.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint-Recob::Shower association is somehow not valid. Stopping";
    return;
  }

  //Get the spacepoints handle and the hit assoication
  art::Handle<std::vector<recob::SpacePoint> > spHandle;
  if (!evt.getByLabel(fPFParticleLabel, spHandle)){
    throw cet::exception("RecoEfficencyFinder") << "Could not configure the spacepoint handle. Something is configured incorrectly. Stopping";
    return;
  }
  art::FindManyP<recob::Hit> fmsph(spHandle, evt, fPFParticleLabel);
  if(!fmsph.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint and hit association not valid. Stopping.";
    return;
  }
  


  //Assn between Tracks and pfparticles
  art::FindManyP<recob::Track> fmt(pfpHandle, evt, fTrackModuleLabel);
  if(!fmt.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Assn between Tracks and calo
  art::FindManyP<anab::Calorimetry> fmcal(trackListHandle, evt, fCalorimetryModuleLabel);
  if(!fmt.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Assn between Tracks and hits
  art::FindManyP<recob::Hit> fmth(trackListHandle, evt, fTrackModuleLabel);
  if(!fmth.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }


  //What energy do we actually reconstruct the shower. 

  //List the particles in the event
  const sim::ParticleList& particles = particleInventory->ParticleList();

  //Make a map of Track id and pdgcode
  std::map<int,int> trueParticleEnergy;
  std::map<int, const simb::MCParticle*> trueParticles;
  for (sim::ParticleList::const_iterator particleIt = particles.begin(); particleIt != particles.end(); ++particleIt){
    const simb::MCParticle *particle = particleIt->second;
    trueParticleEnergy[particle->TrackId()] = 0;
    trueParticles[particle->TrackId()] = particle;

    //    std::cout << "particle id: " << particle->TrackId() << " pdg: " << particle->PdgCode() << " Mother: " << particle->Mother() << " E: " << particle->E() << std::endl;

  }


  //Get the true showers. This is a map of the mother id with the down stream mothers 
  std::map<int,std::vector<int> > trueShowerCandidates = ShowerUtils::GetShowerMothersCandidates(trueParticles);
  std::map<int,float> MCTrack_Energy_map = RecoUtils::TrueEnergyDepositedFromMCTracks(simchannels);

  std::map<int,std::vector<int> > trueShowers;
  //Remove showers candiates  which are not neutrino ones.
  int numVtx=0;
  for(auto const& trueShowerCandidate: trueShowerCandidates){
    
    //Assume anything that comes from the vertex is a shower. 
    for(auto const& mc: mclist){

      //Only deal with neutrinos 
      if(mc->Origin() != simb::kBeamNeutrino){continue;} 

      if(!isFromNuVertex(mc,trueParticles[trueShowerCandidate.first])){continue;}
      
      //Make sure that the shower started is contained
      if(!isShowerContainedish(trueShowerCandidate.second,MCTrack_Energy_map,trueParticles)){continue;}

      //Make sure we are not a silly photon below 10 MeV 
      if(trueParticles[trueShowerCandidate.first]->E()*1000 < 10){continue;}

      trueShowers[trueShowerCandidate.first] = trueShowerCandidate.second;
    }
  }
  trueShowerCandidates.clear();
  
  trueShower_num_branch = trueShowers.size();

  //For the time being Lets not continue without a neutrino vertex in the AV.
  for(auto const& mc: mclist){

    //Only deal with neutrinos 
    if(mc->Origin() != simb::kBeamNeutrino){continue;} 

    //Count the number of vertices that can be reconstructed.
    const TVector3 nuVtx = mc->GetNeutrino().Nu().Trajectory().Position(0).Vect(); 

    if(containedInAV(nuVtx)){
      nu_E_numtrue_branch.push_back(mc->GetNeutrino().Nu().E());
      ++numVtx;
    }
  }

  if(numVtx == 0){return;}

  numtrueVtx_branch = numVtx;

  //Loop over fpf and find the neutrinos
  std::vector<art::Ptr<recob::PFParticle> > neutrinos;
  for(auto const& pfp: pfps){
    if(TMath::Abs(pfp->PdgCode()) == 12 || TMath::Abs(pfp->PdgCode()) == 14){
      neutrinos.push_back(pfp);
    }
  }

  //Make the pfp map
  std::map<int, art::Ptr<recob::PFParticle> > pfp_map;
  for(auto const& pfp: pfps){
      pfp_map[pfp->Self()] = pfp;
  }


  int neutrino_iter=0;

  number_of_showers_per_neutrino.resize(neutrinos.size(),-999);
  vertex_recoKE_branch.resize(neutrinos.size(),-999); 
  vertex_trueKE_branch.resize(neutrinos.size(),-999); 
  vertex_reco_branch.resize(neutrinos.size(),-999);
  nu_reco_energy_branch.resize(neutrinos.size(),-999);
  nu_distance_branch.resize(neutrinos.size(),-999);
  nu_pdg_branch.resize(neutrinos.size(),-999);
  nu_osc_prob_branch.resize(neutrinos.size(),-999);
  in_FV_branch.resize(neutrinos.size(),-999);
  
  shower_energy_branch.resize(neutrinos.size());
  truth_pid_branch.resize(neutrinos.size()); 
  true_energy_branch.resize(neutrinos.size()); 
  shower_coversion_gap_branch.resize(neutrinos.size());
  shower_residual_dist_branch.resize(neutrinos.size());
  shower_len_branch.resize(neutrinos.size());
  shower_length_branch.resize(neutrinos.size());
  shower_density_branch.resize(neutrinos.size());
  shower_length_perp_branch.resize(neutrinos.size());
  shower_density_perp_branch.resize(neutrinos.size());
  shower_density_3D_branch.resize(neutrinos.size());
  shower_density_grad_perp_branch.resize(neutrinos.size());
  shower_density_grad_branch.resize(neutrinos.size());
  shower_density_ratio_branch.resize(neutrinos.size());
  shower_density_grad_ratio_branch.resize(neutrinos.size());
  shower_density_grad_perp_sq_branch.resize(neutrinos.size());
  shower_density_grad_sq_branch.resize(neutrinos.size());
  shower_density_grad_ratio_sq_branch.resize(neutrinos.size());
  shower_density_grad_new_branch.resize(neutrinos.size());
  shower_open_angle_branch.resize(neutrinos.size());
  

  shower_dEdx_branch.resize(neutrinos.size());
  track_lengths_branch.resize(neutrinos.size());   
  nu_truth_energy_branch.resize(neutrinos.size()); 
  nu_interaction_type_branch.resize(neutrinos.size());
  nu_mode_branch.resize(neutrinos.size());
  nu_E_branch.resize(neutrinos.size());
  track_E_branch.resize(neutrinos.size());
  track_trueE_branch.resize(neutrinos.size());
  track_pdg_branch.resize(neutrinos.size());
  truepionE_branch.resize(neutrinos.size());
  trueprotonE_branch.resize(neutrinos.size());
  truekaonE_branch.resize(neutrinos.size());
  truetrackE_branch.resize(neutrinos.size());
  track_resE_branch.resize(neutrinos.size());

  for(auto const neutrino: neutrinos){

    std::vector<art::Ptr<recob::Shower> > neutrino_showers; 
      
    const std::vector<long unsigned int> daughters = neutrino->Daughters();

    for(auto const& daughter: daughters){
      //      std::cout << "daughter id: " << daughter << " pdgcode: " << pfp_map[daughter]->PdgCode() << std::endl;

      //is the daughter a shower.
      if(pfp_map[daughter]->PdgCode() != 11){continue;}

      //Do we have a corresponding shower particle.
      std::vector<art::Ptr<recob::Shower> > shower = fmsh.at(pfp_map[daughter].key());

      //Did we succeed at characterising the shower particle?
      if(shower.size() == 0){std::cout << "no reco shower" << std::endl; continue;}
      

      //If we have two then our charactisation did a silly.
      if(shower.size() != 1){
  	throw cet::exception("RecoEfficencyFinder") << "we have too many recob showers for pfparticles";
  	return;
     }
     
      //Then we have a shower
      neutrino_showers.push_back(shower[0]);

    }
    std::cout << " neutrino_showers.size(): " << neutrino_showers.size() << std::endl;

    //Order the showers with regards to their energy
    std::sort(neutrino_showers.begin(), neutrino_showers.end(),[](const art::Ptr<recob::Shower> & a, const art::Ptr<recob::Shower> & b)
	      { 
		return a->Energy().at(a->best_plane()) > b->Energy().at(b->best_plane()); 
	      });

    //Fill the information about the showers
    for(auto const& shower: neutrino_showers){

      //Check the truth out 
      const int ShowerBest_Plane = shower->best_plane();
      std::pair<int,double> ShowerTrackInfo = ShowerUtils::TrueParticleIDFromTrueChain(trueShowers,fmh.at(shower.key()),ShowerBest_Plane);
      truth_pid_branch.at(neutrino_iter).push_back(ShowerTrackInfo.first);

      float true_energy = 0;
      for(auto const& shower_element: trueShowers[ShowerTrackInfo.first]){
	true_energy += MCTrack_Energy_map[shower_element];
      }

      true_energy_branch.at(neutrino_iter).push_back(true_energy);

      //Lets also fill the dEdx.
      shower_dEdx_branch.at(neutrino_iter).push_back(shower->dEdx().at(ShowerBest_Plane));
      //Apply reconstruction energy cut. 
      const std::vector<double> ShowerEnergyPlanes = shower->Energy(); //MeV
      //      auto const  max_shower_energy = *max_element(std::begin(ShowerEnergyPlanes), std::end(ShowerEnergyPlanes));
      float max_shower_energy = ShowerEnergyPlanes[0];
      if(ShowerBest_Plane != -999){
	if((int) ShowerEnergyPlanes.size() < ShowerBest_Plane+1){
	  max_shower_energy = ShowerEnergyPlanes[ShowerBest_Plane];
	}
      }

      double ShowerLength  = shower->Length();

      //      if(max_shower_energy > fMinRecoEnergyCut){
      shower_energy_branch.at(neutrino_iter).push_back(max_shower_energy);
      shower_length_branch.at(neutrino_iter).push_back(ShowerLength);
      shower_density_branch.at(neutrino_iter).push_back(max_shower_energy/ShowerLength);
	//     }

      const TVector3 ShowerStart     = shower->ShowerStart();
      const TVector3 ShowerDirection = shower->Direction();
      double ShowerOpenAngle         = shower->OpenAngle();

      //Get the hits
      std::vector<art::Ptr<recob::SpacePoint> > showerhits = fmsp.at(shower.key());

      //Workout the perpendicular length. Order hits based on the start position and direction
      OrderPerpendiuclarShowerHits(showerhits,ShowerStart,ShowerDirection);
      int length_iter = 0.9*showerhits.size();
      TVector3 EndPosition = SpacePointPosition(showerhits[length_iter]);
      TVector3 RelativeEndPos = EndPosition - ShowerStart;
      double ShowerPerpendicularLength = 2*(RelativeEndPos - (RelativeEndPos.Dot(ShowerDirection))*ShowerDirection).Mag();
      
      //Workout Perpendicular density
      double ShowerPerpendicularDensity = max_shower_energy/ShowerPerpendicularLength;

      //Workout 3D density.			
      double Shower3DDensity= max_shower_energy/(ShowerPerpendicularLength*ShowerPerpendicularLength*ShowerLength);

      //      std::cout << "ShowerPerpendicularLength: " << ShowerPerpendicularLength << " ShowerPerpendicularDensity: " << ShowerPerpendicularDensity << " Shower3DDensity: " << Shower3DDensity << std::endl;

      //Workout density gradients
      double showerperpendiculardensitygradient = ShowerPerpendicularDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerPerpendicularLength,fmsph);

      OrderShowerHits(showerhits,ShowerStart,ShowerDirection);
      std::cout << "Shower Energy: " << max_shower_energy << std::endl;
      double showerdensitygradient = ShowerDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerLength,fmsph);
      double showerdensitygradient_new = ShowerDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerLength,ShowerOpenAngle, fmsph);
	
      //      std::cout << "ShowerPerpendicularDensityGradient: " << showerperpendiculardensitygradient << " ShowerDensityGradient: " << showerdensitygradient << std::endl;

      shower_length_perp_branch.at(neutrino_iter).push_back(ShowerPerpendicularLength);
      shower_density_perp_branch.at(neutrino_iter).push_back(ShowerPerpendicularDensity);
      shower_density_3D_branch.at(neutrino_iter).push_back(Shower3DDensity);
      shower_density_grad_perp_branch.at(neutrino_iter).push_back(showerperpendiculardensitygradient);
      shower_density_grad_branch.at(neutrino_iter).push_back(showerdensitygradient);
      shower_density_grad_new_branch.at(neutrino_iter).push_back(showerdensitygradient_new);
      shower_open_angle_branch.at(neutrino_iter).push_back(ShowerOpenAngle);

      shower_density_ratio_branch.at(neutrino_iter).push_back(ShowerLength/ShowerPerpendicularLength);
      shower_density_grad_ratio_branch.at(neutrino_iter).push_back(showerdensitygradient/showerperpendiculardensitygradient);

      shower_density_grad_perp_sq_branch.at(neutrino_iter).push_back(showerdensitygradient*showerdensitygradient);
      shower_density_grad_sq_branch.at(neutrino_iter).push_back(showerperpendiculardensitygradient*showerperpendiculardensitygradient);
      shower_density_grad_ratio_sq_branch.at(neutrino_iter).push_back(showerdensitygradient/showerperpendiculardensitygradient*showerdensitygradient/showerperpendiculardensitygradient);
      

    }

    //Add the number of showers to the true.
    number_of_showers_per_neutrino.at(neutrino_iter) = neutrino_showers.size();
    
    //Neutrino Pdg 
    nu_pdg_branch.at(neutrino_iter) = neutrino->PdgCode();

    //How well do we reconstruct the vertex. 

    //Define the vertex as being correct if within 5cm 
    std::vector<art::Ptr<recob::Vertex> > vertex = fmv.at(neutrino.key());

    if(vertex.size() > 1){
      throw cet::exception("RecoEfficencyFinder") << "we have too many recob vertex for pfparticles";
      return;
    }

    double vtx_xyz[3] = {-999,-999,-999};
    vertex[0]->XYZ(vtx_xyz);
     
    TVector3 vertex_position = {vtx_xyz[0],vtx_xyz[1],vtx_xyz[2]};

    //Ask if the vertex was in the FV
    if(containedInFV(vertex_position)){
      in_FV_branch.at(neutrino_iter) = 1;
    }
    else{
      in_FV_branch.at(neutrino_iter) = 0;
    }

    //Find the corresponding vertex. Hopefully there is just one event but pileup is ~few% 
    bool isReconstructed = false;
    
    if(mclist.size() < 1){
      throw cet::exception("RecoEfficencyFinder") << "why no truth :(";
      return;
    }

    art::Ptr<simb::MCTruth> mc_truth = mclist[0];
    int mc_truth_iter = 0;
    for(auto const& mc: mclist){
      ++mc_truth_iter;
      isReconstructed = isFromNuVertex(mc,vertex_position);
      if(isReconstructed){
	++num_v_recoed;
  	mc_truth = mc;
  	break;
      }
    }
    --mc_truth_iter;
    
    //Calculate the oscillation probability for the event
    int initnu =  mcflux->at(mc_truth.key()).fntype;
    int finnu  =  mc_truth->GetNeutrino().Nu().PdgCode();
    float nudistance = mcflux->at(mc_truth_iter).fdk2gen + mcflux->at(mc_truth_iter).fgen2vtx;
    float loverE = nudistance/mc_truth->GetNeutrino().Nu().E();
    double osc_prob = SignalOscillationWeight(initnu,finnu,loverE);
    
    nu_osc_prob_branch.at(neutrino_iter) = osc_prob;
    nu_distance_branch.at(neutrino_iter) = nudistance;
    nu_interaction_type_branch.at(neutrino_iter) = mc_truth->GetNeutrino().InteractionType();
    nu_mode_branch.at(neutrino_iter)             = mc_truth->GetNeutrino().Mode();
    nu_E_branch.at(neutrino_iter)                = mc_truth->GetNeutrino().Nu().E();

    //Get the true vertex KE
    float True_Vertex_Energy = 0;
    for(auto const& track: MCTrack_Energy_map){
      if(isPrimaryHadron(track.first,mc_truth,trueParticles,neutrino_iter,MCTrack_Energy_map)){
  	True_Vertex_Energy += track.second;
      }
    }
    vertex_trueKE_branch.at(neutrino_iter) = True_Vertex_Energy;

    if(isReconstructed){
      vertex_reco_branch.at(neutrino_iter) = 1;
    }

    //Loop over hadron daughter pfps and calculate the energy
    float Vertex_KE = 0;
    for(auto const& daughter: daughters){
      
      if(pfp_map[daughter]->PdgCode() == 11){continue;}

      art::Ptr<recob::PFParticle> daughter_pfp = pfp_map[daughter];

      //Get the track info 
      std::vector<art::Ptr<recob::Track> > daughter_track = fmt.at(daughter_pfp.key());
      if(daughter_track.size() == 0){continue;}
      if(daughter_track.size() != 1){
	throw cet::exception("RecoEfficencyFinder") << "we have too many recob tracks for pfparticles";
	return;
      }

      //Add the length 
      track_lengths_branch.at(neutrino_iter).push_back(daughter_track[0]->Length());

      //Get the calorimetry info
      std::vector<art::Ptr<anab::Calorimetry> > daughter_calo = fmcal.at(daughter_track[0].key());
      if(daughter_calo.size() != 3){continue;}
      // if(daughter_calo.size() != 1){
      // 	throw cet::exception("RecoEfficencyFinder") << "we have too many calos for tracks" << daughter_calo.size() << std::endl;â‚¬;
      //   return;
      // }
      Vertex_KE += daughter_calo[2]->KineticEnergy(); 
    }
    vertex_recoKE_branch.at(neutrino_iter) = Vertex_KE;
  
    //Get the conversion gap 
    float min_coversion_gap = 999;
    int min_convgap_key = 0;
    int convgap_key = 0;
    for(auto const& neutrino_shower: neutrino_showers){

      //Get the conversion gap 
      TVector3 ShowerStart     = neutrino_shower->ShowerStart();//cm 
      double   conversion_gap  = (ShowerStart - vertex_position).Mag();
      shower_coversion_gap_branch.at(neutrino_iter).push_back(conversion_gap);
      
      //Get the closest shower to the vertex.
      if(conversion_gap < min_coversion_gap){
	min_convgap_key = convgap_key;
      }
      ++convgap_key;
    }

    //Calculate the residual of the closest shower
    for(auto const& neutrino_shower: neutrino_showers){
      TVector3 ShowerStart     = neutrino_shower->ShowerStart();//cm 
      TVector3 conversion_vec  = (ShowerStart - vertex_position);
      
      TVector3 min_conversion_vec = (neutrino_showers[min_convgap_key]->ShowerStart() - vertex_position).Unit();

      double len  = conversion_vec.Dot(min_conversion_vec);
      double perp = (conversion_vec - len*min_conversion_vec).Mag();
      shower_len_branch.at(neutrino_iter).push_back(len);
      shower_residual_dist_branch.at(neutrino_iter).push_back(perp);
    }
  
    //Get the total reco energy.
    float Nu_reco_Energy = 0;
    float max_s_energy = -999;
    for(auto const& pfp: pfp_map){
      art::Ptr<recob::PFParticle> parent   = pfp.second;
      art::Ptr<recob::PFParticle> temp_pfp = pfp.second;
      
      //Get the primary particle
      while(!parent->IsPrimary()){
  	temp_pfp = parent;
  	if(pfp_map.find(parent->Self()) == pfp_map.end()){parent = temp_pfp; break;}
  	parent = pfp_map[parent->Parent()];
      }

      //Check we come from the neutrino
      if(parent->Self() != neutrino->Self()){continue;}

      //Get the energy from tracks
      if(pfp.second->PdgCode() == 13){

  	//Get the track info 
  	std::vector<art::Ptr<recob::Track> > track = fmt.at(pfp.second.key());
  	if(track.size() == 0){continue;}
  	if(track.size() != 1){
  	  throw cet::exception("RecoEfficencyFinder") << "we have too many recob tracks for pfparticles";
  	  return;
  	}

  	//Get the calorimetry info
  	std::vector<art::Ptr<anab::Calorimetry> > calo = fmcal.at(track[0].key());
  	if(calo.size() != 3){continue;}
	//  	if(calo.size() != 1){
  	//  throw cet::exception("RecoEfficencyFinder") << "we have too many calos for tracks";
  	//  return;
  	//}
	float TrackEnergy = calo[2]->KineticEnergy();

  	Nu_reco_Energy += TrackEnergy;
      
	std::vector<art::Ptr<recob::Hit> > track_hits = fmth.at(track[0].key());

	//Get the true track id
	int truetrack_id = RecoUtils::TrueParticleIDFromTotalRecoHits(track_hits);
	if(MCTrack_Energy_map.find(truetrack_id) == MCTrack_Energy_map.end()){continue;}
        if(trueParticles.find(truetrack_id) == trueParticles.end()){continue;} 
	track_E_branch.at(neutrino_iter).push_back(TrackEnergy);
	track_trueE_branch.at(neutrino_iter).push_back(MCTrack_Energy_map[truetrack_id]);
	track_pdg_branch.at(neutrino_iter).push_back(trueParticles[truetrack_id]->PdgCode());
	track_resE_branch.at(neutrino_iter).push_back((MCTrack_Energy_map[truetrack_id]-TrackEnergy)/MCTrack_Energy_map[truetrack_id]);
      
      }

      //is the daughter a shower.
      if(pfp.second->PdgCode() == 11){

  	//Do we have a corresponding shower particle.
  	std::vector<art::Ptr<recob::Shower> > shower = fmsh.at(pfp.second.key());
	
  	//Did we succeed at characterising the shower particle?
  	if(shower.size() == 0){continue;}
	
	
  	//If we have two then our charactisation did a silly.
  	if(shower.size() != 1){
  	  throw cet::exception("RecoEfficencyFinder") << "we have too many recob showers for pfparticles";
  	  return;
  	}

  	//Apply reconstruction energy cut. 
	const int ShowerBest_Plane = shower[0]->best_plane();
  	const std::vector<double> ShowerEnergyPlanes = shower[0]->Energy(); //MeV
	//  	auto const  max_shower_energy = *max_element(std::begin(ShowerEnergyPlanes), std::end(ShowerEnergyPlanes));
	float max_shower_energy = ShowerEnergyPlanes[0];
	if(ShowerBest_Plane != -999){
	  if((int) ShowerEnergyPlanes.size() > ShowerBest_Plane+1){
	    max_shower_energy = ShowerEnergyPlanes[ShowerBest_Plane];
	  }
	}

  	if(pfp.second->Parent() == neutrino->Self()){
  	  if(max_shower_energy > max_s_energy){
  	    max_s_energy = max_shower_energy;
  	    //Then we have a shower
  	  }
  	}
  	else{
  	  Nu_reco_Energy += max_shower_energy;
  	}
      }
    }
    Nu_reco_Energy += max_s_energy;
    nu_reco_energy_branch.at(neutrino_iter) = Nu_reco_Energy;

    //Get the truth energy
    nu_truth_energy_branch.at(neutrino_iter) = mc_truth->GetNeutrino().Nu().E();
    ++neutrino_iter;
  }


  Tree->Fill();

  number_of_showers_per_neutrino.clear();
  shower_energy_branch.clear();
  truth_pid_branch.clear();
  true_energy_branch.clear();
  vertex_recoKE_branch.clear();
  vertex_trueKE_branch.clear();
  vertex_reco_branch.clear();
  track_lengths_branch.clear();
  shower_coversion_gap_branch.clear();
  shower_residual_dist_branch.clear();
  shower_length_perp_branch.clear();
  shower_density_perp_branch.clear();
  shower_density_3D_branch.clear();
  shower_density_grad_perp_branch.clear();
  shower_density_grad_branch.clear();
  shower_density_ratio_branch.clear();
  shower_density_grad_ratio_branch.clear();
  shower_len_branch.clear();
  shower_dEdx_branch.clear();
  nu_reco_energy_branch.clear();
  nu_truth_energy_branch.clear();
  nu_interaction_type_branch.clear();
  nu_mode_branch.clear();
  nu_E_branch.clear(); 
  nu_E_numtrue_branch.clear();
  nu_distance_branch.clear();
  track_E_branch.clear();
  track_trueE_branch.clear();
  track_pdg_branch.clear();
  truetrackE_branch.clear();
  truepionE_branch.clear();
  trueprotonE_branch.clear();
  truekaonE_branch.clear();
  track_resE_branch.clear();
  shower_length_branch.clear();
  shower_density_branch.clear();
  in_FV_branch.clear();
  shower_density_grad_perp_sq_branch.clear();
  shower_density_grad_sq_branch.clear();
  shower_density_grad_ratio_sq_branch.clear();
  nu_osc_prob_branch.clear();
  nu_pdg_branch.clear();
  shower_density_grad_new_branch.clear();
  shower_open_angle_branch.clear();

}

void ana::RecoEfficencyFinder::endJob(){

  int i=0;
  for(auto& segment: SegmentDensityPerpFinal){
    segment = segment/SegmentDensityPerpFinalN[i];
    std::cout << " i: " << i << " segment: " << segment << std::endl;
    SegmentDensityPerpGraph->SetPoint(SegmentDensityPerpGraph->GetN(),i,segment);
    ++i;
  }

  i=0;
  for(auto& segment: SegmentDensityFinal){
    segment =  segment/SegmentDensityFinalN[i];
    std::cout << " i: " << i << " segment: " << segment << std::endl;
    SegmentDensityGraph->SetPoint(SegmentDensityGraph->GetN(),i,segment);
    ++i;
  }

  std::cout << "num_v_recoed: " << num_v_recoed << std::endl;
}

bool ana::RecoEfficencyFinder::isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance) const{
  
  const TLorentzVector nuVtx     = mc->GetNeutrino().Nu().Trajectory().Position(0);
  const TLorentzVector partstart = particle->Position();
  return TMath::Abs((partstart - nuVtx).Mag()) < distance;
}

bool ana::RecoEfficencyFinder::isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, TVector3& position, float distance) const{
  
  const TVector3 nuVtx     = mc->GetNeutrino().Nu().Trajectory().Position(0).Vect();
  return TMath::Abs((position - nuVtx).Mag()) < distance;
}

//Check if the point is in the Active volume.
bool ana::RecoEfficencyFinder::containedInAV(const TVector3 &v) {
  for (auto const& AV: fActiveVolume) {
    if (AV.ContainsPosition(v)) return true;
  }
  return false;
}

//Check if the point is in the Active volume.
bool ana::RecoEfficencyFinder::containedInFV(const TVector3 &v) {
  for (auto const& FV: fFiducalVolume) {
    if (FV.ContainsPosition(v)) return true;
  }
  return false;
}


bool ana::RecoEfficencyFinder::isShowerContainedish(const std::vector<int>& shower, std::map<int,float>& Track_Energy_map, std::map<int, const simb::MCParticle*>& trueParticles){

  //Add up the energy of the shower
  float Energy = 0;
  for(auto const& shower_part: shower){
    Energy += trueParticles[shower_part]->E();
  }
  
  //Add up the deposited energy of the shower 
  float deposited_Energy = 0;
  for(auto const& shower_part: shower){
    deposited_Energy += Track_Energy_map[shower_part];
  }

  //If more than 90% of the shower has been identified on the collection plane it is contained.
  if(deposited_Energy/Energy > 0.9){return true;}
  
  return false;

}


bool ana::RecoEfficencyFinder::isPrimaryHadron(const int& track, art::Ptr<simb::MCTruth>& mc_truth, std::map<int,const simb::MCParticle*>& trueParticles,int neutrino_iter,std::map<int,float>& Track_Energy_map){

  if(trueParticles.find(track) == trueParticles.end()){return false;}

  //Check that it is from the vertex. 
  if(!isFromNuVertex(mc_truth,trueParticles[track])){
    return false;
  }

  truetrackE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);

  //Check if its a hadron 
  if(TMath::Abs(trueParticles[track]->PdgCode()) != 2212 &&
     TMath::Abs(trueParticles[track]->PdgCode()) != 211  &&
     TMath::Abs(trueParticles[track]->PdgCode()) != 321)
    {return false;}
  

  if(TMath::Abs(trueParticles[track]->PdgCode()) == 211){truepionE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}
  if(TMath::Abs(trueParticles[track]->PdgCode()) == 2212){trueprotonE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}
  if(TMath::Abs(trueParticles[track]->PdgCode()) == 321){truekaonE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}

  return true;
}

//Orders hits from the distance away from the shower stem.
void ana::RecoEfficencyFinder::OrderPerpendiuclarShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection){
  
  std::map<double,art::Ptr<recob::SpacePoint> > OrderedSpacePoints;

  //Loop over the spacepoints and get the pojected distance from the vertex.
  for(auto const& sp: sps){

    // Get the projection of the space point along the direction
    double len = SpacePointProjection(sp, ShowerStartPosition, ShowerDirection);

    //Get the length to the projection
    TVector3 perp = (SpacePointPosition(sp)-ShowerStartPosition) - len*ShowerDirection;
    double  len_perp = perp.Mag();
    

    //Add to the list
    OrderedSpacePoints[len_perp] = sp;
  }

  //Return an ordered list.
  sps.clear();
  for(auto const& sp: OrderedSpacePoints){
    sps.push_back(sp.second);
  }
  return;
}

void ana::RecoEfficencyFinder::OrderShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection){
  
  std::map<double,art::Ptr<recob::SpacePoint> > OrderedSpacePoints;

  //Loop over the spacepoints and get the pojected distance from the vertex.
  for(auto const& sp: sps){

    // Get the projection of the space point along the direction
    double len = SpacePointProjection(sp, ShowerStartPosition, ShowerDirection);

    //Add to the list
    OrderedSpacePoints[len] = sp;
  }

  //Return an ordered list.
  sps.clear();
  for(auto const& sp: OrderedSpacePoints){
    sps.push_back(sp.second);
  }
  return;
}


double ana::RecoEfficencyFinder::ShowerPerpendicularDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerPerpendicularLength, art::FindManyP<recob::Hit> const& fmh){

  //  std::cout << "On perpendiular density" << std::endl;

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerPerpendicularLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - len*ShowerDirection ;
    double  len_perp = perp.Mag();
    
    //Get where the sp should be place.
    int sg_len = round(len_perp/segmentsize);

    len_segment_map[sg_len].push_back(sp);
  }

  double PreviousLength = -9999;

  //Loop over the segment and calculate the desnity
  float sumx=0;
  float sumy=0;
  float sumx2=0;
  float sumy2=0;
  float sumxy=0;
  float n=0;
  //Calculate the density gradent.
  for(auto& segment: len_segment_map){
    
    if(segment.second.size() < 5){continue;}

    //Reorder the Segements
    OrderShowerHits(segment.second,ShowerStartPosition,ShowerDirection);

    //Calculate the length 
    int length_iter         = 0.9*segment.second.size();
    TVector3 EndPosition    = SpacePointPosition(segment.second[length_iter]);
    TVector3 StartPosition  = SpacePointPosition(segment.second[0]); 

    double StartPoistionLength = (StartPosition - ShowerStartPosition).Dot(ShowerDirection);
    double EndPoisitionLength  = (EndPosition - ShowerStartPosition).Dot(ShowerDirection);

    double SegmentLength      = TMath::Abs(EndPoisitionLength-StartPoistionLength);

    if(SegmentLength == 0){continue;}

    //Force the length of the segment to be equal or larger than the last one
    if(SegmentLength < PreviousLength){SegmentLength = PreviousLength;}

    //Calculate the charge in the segement
    double SegmentCharge = TotalCharge(segment.second,fmh);

    double SegmentEnergy =  SegmentCharge*0.00153631;
    
    //Calculate the density 
    double SegmentDensity = -99999;

    if(segment.first == 0){
      SegmentDensity = (SegmentEnergy/(SegmentLength*segmentsize/2*segmentsize/2));
    }
    else{
      SegmentDensity = (SegmentEnergy/(SegmentLength*segmentsize*segmentsize));
    }

    //std::cout << "SegmentDensityPerpFinal.size(): " << SegmentDensityPerpFinal.size() << " segment.first: " << segment.first << std::endl;
    if(segment.first > -1 && segment.first < fNSegments){
      SegmentDensityPerpFinal.at(segment.first) += SegmentDensity;
      ++SegmentDensityPerpFinalN.at(segment.first);
    }


    double LengthToSegment = segment.first * segmentsize;

     //    std::cout << "Charge: " << SegmentCharge << " Length: " << SegmentLength << " Size: " << segmentsize << " numhits: " << segment.second.size() << " Density: " << SegmentDensity << std::endl;

    //Calculate the gradient using regression
    sumx  += LengthToSegment;
    sumy  += SegmentDensity;
    sumx2 += LengthToSegment * LengthToSegment;
    sumy2 += SegmentDensity*SegmentDensity;
    sumxy += LengthToSegment * SegmentDensity;
    ++n;
    
    PreviousLength = SegmentLength;
  }

  if((sumx2 - sumx*sumx) == 0){return 0;}
  
  double Densitygradient = (sumxy - sumx*sumy/n)/(sumx2 - sumx*sumx/n);
  return Densitygradient;
}

double ana::RecoEfficencyFinder::ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, double& OpenAngle, art::FindManyP<recob::Hit> const& fmh){

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - (len*ShowerDirection);
    double perpLen = perp.Mag();

    //Get where the sp should be place.
    int sg_len = round(len/segmentsize);

    //    std::cout << "perpLen: " << perpLen << "TMath::Tan(0.5*OpenAngle)*len: " << TMath::Tan(0.5*OpenAngle)*len << "OpenAngle: " << OpenAngle << " len: " << len  << std::endl;

    //Only add if the hit within the cone
    if(perpLen > TMath::Tan(0.5*OpenAngle)*len){continue;}

    len_segment_map[sg_len].push_back(sp);
    
  }

  TGraph* graph = new TGraph();

  //Calculate the density gradent.
  for(auto& segment: len_segment_map){
    double sg_len = segment.first;
    
    if(segment.second.size() < 10){continue;}

    //Calculate the charge in the segement
    double SegmentEnergy = TotalEnergy(segment.second,fmh);
    
    //Calculate the voume
    double lower_dist = sg_len*segmentsize - segmentsize/2;
    double upper_dist = sg_len*segmentsize + segmentsize/2;
    
    if(sg_len==0 || sg_len==fNSegments){continue;}

    if(sg_len==0)         {lower_dist = 0;}
    if(sg_len==fNSegments){upper_dist = sg_len*segmentsize;}
    
    double littlevolume = lower_dist*TMath::Power((TMath::Tan(0.5*OpenAngle)*lower_dist),2)*TMath::Pi()/3;
    double bigvolume    = upper_dist*TMath::Power((TMath::Tan(0.5*OpenAngle)*upper_dist),2)*TMath::Pi()/3;
    double volume       = bigvolume - littlevolume;
    
    double SegmentDensity = SegmentEnergy/volume;

    double LengthToSegment = (lower_dist+upper_dist)/2;

    std::cout << "sg_len: " << sg_len << "Energy: " << SegmentEnergy << "volume: " << volume << " Length: " << LengthToSegment << " Size: " << segmentsize << " numhits: " << segment.second.size() << " Density: " << SegmentDensity << std::endl;

    
    graph->SetPoint(graph->GetN(),LengthToSegment,SegmentDensity);
  }
  
  if(graph->GetN() == 0){return 0;}
  
  TF1 *fit = new TF1("fit", "[0] + [1]/x^2");
  graph->Fit(fit,"Q");
  
  double grad = fit->GetParameter(1);
  

  delete fit;
  delete graph;

  std::cout << "grad: " << grad << std::endl;
  return grad;
}

double ana::RecoEfficencyFinder::ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, art::FindManyP<recob::Hit> const& fmh){

  //  std::cout << "on gradient" << std::endl;

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - len*ShowerDirection;
    
    //Get where the sp should be place.
    int sg_len = round(len/segmentsize);
    len_segment_map[sg_len].push_back(sp);
  }

  double PreviousSegmentPendicularLength = -99999;

  //Loop over the segment and calculate the desnity
  // float sumx=0;
  // float sumy=0;
  // float sumx2=0;
  // float sumy2=0;
  // float sumxy=0;
  // float n=0;

  TGraph* graph = new TGraph();

  //Calculate the density gradent.
  for(auto& segment: len_segment_map){

    //Reorder the Segements
    OrderPerpendiuclarShowerHits(segment.second,ShowerStartPosition,ShowerDirection);

    if(segment.second.size() < 5){continue;}

    //Calculate the length 
    int length_iter = 0.9*segment.second.size();
    TVector3 EndPosition    = SpacePointPosition(segment.second[length_iter]);
    double len = (ShowerStartPosition - EndPosition).Dot(ShowerDirection);

    //Get the length to the projection                                                            
    TVector3 perp = (ShowerStartPosition - EndPosition) - len*ShowerDirection;
    double  SegmentPendicularLength = 2*perp.Mag();

    if(SegmentPendicularLength == 0){continue;}

    if(SegmentPendicularLength < PreviousSegmentPendicularLength){SegmentPendicularLength = PreviousSegmentPendicularLength;} 

    //Calculate the charge in the segement
    double SegmentCharge = TotalCharge(segment.second,fmh);

    //Calculate the Energy.
    double SegmentEnergy =  SegmentCharge*0.00153631;

    //Calculate the density 
    double SegmentDensity = -99999;

    if(segment.first == 0){
      SegmentDensity = (SegmentEnergy/(SegmentPendicularLength*SegmentPendicularLength*segmentsize/2));
    }
    else{
      SegmentDensity = (SegmentEnergy/(SegmentPendicularLength*SegmentPendicularLength*segmentsize));
    }

    //std::cout << "SegmentDensityFinal.size(): " << SegmentDensityFinal.size() << " segment.first: " << segment.first << std::endl;
    if(segment.first > -1 && segment.first < fNSegments){
      SegmentDensityFinal.at(segment.first) += SegmentDensity;
      ++SegmentDensityFinalN.at(segment.first);
    }

    double LengthToSegment = segment.first * segmentsize;

    //    std::cout << "Charge: " << SegmentCharge << " LengthToSegment: " << LengthToSegment << " Perp Length: " << SegmentPendicularLength << " segment.first: " << segment.first << " Size: " << segmentsize << " numhits: " << segment.second.size() << " SegmentDensity: " << SegmentDensity <<  std::endl;

    graph->SetPoint(graph->GetN(),LengthToSegment,SegmentDensity);

    //Calculate the gradient using regression
    // sumx  += LengthToSegment;
    // sumy  += SegmentDensity;
    // sumx2 += LengthToSegment  * LengthToSegment;
    // sumy2 += SegmentDensity * SegmentDensity;
    // sumxy += SegmentDensity * LengthToSegment;
    // ++n;
    // std::cout << "sumxy: " << sumxy << " sumx*sumy: " << sumx*sumy << "  (sumxy - sumx*sumy): " <<  (sumxy - sumx*sumy) << std::endl;
    // std::cout << "sumx2: " << sumx2 << " sumx*sumx: " << sumx*sumx << " (sumx2 - sumx*sumx): " << (sumx2 - sumx*sumx) << std::endl; 

    PreviousSegmentPendicularLength = SegmentPendicularLength;
  }

  if(graph->GetN() == 0){return 0;}

  TF1 *fit = new TF1("fit", "[0] + [1]/x^2");
  graph->Fit(fit,"Q");
  double grad =  fit->GetParameter(1);
  delete fit;
  delete graph;

  //  std::cout << "grad: " << grad << std::endl;
  ++Nfinal;
  return grad;

  // if((sumx2 - sumx*sumx) == 0){return 0;}

  // ++Nfinal;
  
  // double Densitygradient = (sumxy - sumx*sumy/n)/(sumx2 - sumx*sumx/n);
  // return Densitygradient;

}


double ana::RecoEfficencyFinder::TotalEnergy(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh){
  
  std::map<int,double> TotalCharge_plane;
  std::map<int,int> TotalCharge_int;
  for(auto const& sp: sps){
    double Charge =  SpacePointCharge(sp,fmh);
    double Time   =  SpacePointTime(sp,fmh);
    int    Plane  =  SpacePointPlane(sp,fmh);
    Charge *= TMath::Exp((fDetProp->SamplingRate() * Time ) / (fDetProp->ElectronLifetime()*1e3));
    TotalCharge_plane[Plane] += Charge;
    ++TotalCharge_int[Plane];
  }

  int max_plane = -999;
  for(auto const& plane: TotalCharge_int){
    if(plane.second > max_plane){
      max_plane = plane.first;
    }
  }
  if(max_plane == -999){return 0;}
    
  double TotalEnergy = TotalCharge_plane[max_plane]*fConversion[max_plane];

  return TotalEnergy; 
}

double ana::RecoEfficencyFinder::TotalCharge(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh){
  
  double TotalCharge = 0;

  for(auto const& sp: sps){
    double Charge =  SpacePointCharge(sp,fmh);
    double Time   =  SpacePointTime(sp,fmh);
    Charge *= TMath::Exp((fDetProp->SamplingRate() * Time ) / (fDetProp->ElectronLifetime()*1e3));
    TotalCharge += Charge;
  }
  return TotalCharge; 
}


int ana::RecoEfficencyFinder::SpacePointPlane(art::Ptr<recob::SpacePoint> const& sp,
						  art::FindManyP<recob::Hit> const& fmh) const {

  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());

  if(hits.size() != 1){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint is not matched to 1 hit. This was unexpected";
  }

  return hits[0]->WireID().Plane;

}

double ana::RecoEfficencyFinder::SpacePointCharge(art::Ptr<recob::SpacePoint> const& sp,
						  art::FindManyP<recob::Hit> const& fmh) const {
  
  double Charge = 0;
  
  //Average over the charge even though there is only one
  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());
  for(auto const& hit: hits){
    Charge += hit->Integral();
  }
  
  Charge /= (float) hits.size();
  
  return Charge;
}

//Return the spacepoint time.
double ana::RecoEfficencyFinder::SpacePointTime(art::Ptr<recob::SpacePoint> const& sp,
						art::FindManyP<recob::Hit> const& fmh) const {
  
  double Time = 0;

  //Avergae over the hits
  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());
  for(auto const& hit: hits){
    Time += hit->PeakTime();
  }

  Time /= (float) hits.size();
  return Time;
}


double ana::RecoEfficencyFinder::SpacePointProjection(const art::Ptr<recob::SpacePoint>&sp,
					      TVector3 const& vertex, 
					      TVector3 const& direction) const {

  // Get the position of the spacepoint
  TVector3 pos = SpacePointPosition(sp) - vertex;

  // Get the the projected length
  double projLen = pos.Dot(direction);

  return projLen;
}

TVector3 ana::RecoEfficencyFinder::SpacePointPosition(art::Ptr<recob::SpacePoint> const& sp) const {

  const Double32_t* sp_xyz = sp->XYZ();
  TVector3 sp_postiion = {sp_xyz[0], sp_xyz[1], sp_xyz[2]};
  return sp_postiion;
}

//Assumes dm_21=dm_12=dm_13...=0 
double ana::RecoEfficencyFinder::SignalOscillationWeight(int& initpdg, int& finpdg, float& lOverE) const {

  //Madness We do not oscillate intrinsic nues :O 
  if(TMath::Abs(initpdg) == 12){
    if(initpdg == finpdg){ 
      return 1;
    }
    return 0;
  }

  //Calculate the OscProbability 
  double sindm = std::sin(fOscDimensFactor * lOverE/1000 * fdmsq);
  double sinsqdm = sindm * sindm;
  
  double OscProb = 1; 

  if(TMath::Abs(initpdg) == 14){
    if(TMath::Abs(finpdg) == 14){
      OscProb = 1-fsinsq2thmumu * sinsqdm;
    }
    else{
      OscProb = fsinsq2thmue * sinsqdm;
    }
  }
  return OscProb;
}


DEFINE_ART_MODULE(ana::RecoEfficencyFinder)
