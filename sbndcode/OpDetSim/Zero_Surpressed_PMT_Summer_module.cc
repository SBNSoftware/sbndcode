////////////////////////////////////////////////////////////////////////
// Class:       Zero_Surpressed_PMT_Summer
// Module Type: producer
// File:        Zero_Surpressed_PMT_Summer_module.cc
//
// Produces a raw waveform sum. Zero-surpression is achieved by including
// Samples near threshold crossings 
// Enables simple hit detection through multi-pmt-coincidence
// Authors: J. McLaughlin; 
////////////////////////////////////////////////////////////////////////

//Assorted includes 
#include <algorithm>
#include <vector>
#include <cmath>
#include <memory>
#include <string>

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "sbndcode/OpDetSim/sbndPDMapAlg.hh"


class ZeroSurpressedPMTSummer: public art::EDProducer {
public:
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    // Plugins should not be copied or assigned.
   explicit ZeroSurpressedPMTSummer(fhicl::ParameterSet const & p);
   ZeroSurpressedPMTSummer(ZeroSurpressedPMTSummer const &) = delete;
   ZeroSurpressedPMTSummer(ZeroSurpressedPMTSummer &&) = delete;
   ZeroSurpressedPMTSummer & operator = (ZeroSurpressedPMTSummer const &) = delete;
   ZeroSurpressedPMTSummer & operator = (ZeroSurpressedPMTSummer &&) = delete;
   double GetWaveformMedian(raw::OpDetWaveform wvf);
   // Required functions.
   void produce(art::Event & evt) override;
private:
    int fSummingThreshold;
    int fSummingWindow;
    std::string fch_instance_name;
    int fTypicalWvfmSize;
    int fBaselineValue;
    int fTotalCAENBoards;
    std::string fInputModuleName;
    std::string fInputProcessName;
    std::string fInputInstanceName;
    std::vector<std::string> fOpDetsToPlot;
    opdet::sbndPDMapAlg pdMap;
    //Need to handle baselines
};


ZeroSurpressedPMTSummer::ZeroSurpressedPMTSummer(fhicl::ParameterSet const& p)
    : EDProducer{p}  // ,
{
    fInputModuleName = p.get< std::string >("InputModule" );
    fInputProcessName = p.get< std::string >("InputProcess" );
    fInputInstanceName = p.get< std::string >("InputInstance" );
    fBaselineValue = p.get<int>("BaselineADCValue", 14255);
    fSummingThreshold = p.get<int>("ADCThreshold", 8);
    fSummingWindow = p.get<int>("HalfWindowSize", 20);
    fch_instance_name = p.get<std::string>("pmtSumInstanceName","BackSubSummedWaveform");
    fTypicalWvfmSize = p.get<int>("nominal_length", 5000);
    fTotalCAENBoards = p.get<int>("totalCAENBaord", 9);
    produces< std::vector< raw::OpDetWaveform > >(fch_instance_name);
    fOpDetsToPlot = p.get<std::vector<std::string>>("OpDetsToPlot", {"pmt_coated", "pmt_uncoated"});
}

void ZeroSurpressedPMTSummer::produce(art::Event& evt)
{
    art::Handle< std::vector< raw::OpDetWaveform > > waveHandle; //User handle for vector of OpDetWaveforms
    evt.getByLabel(fInputModuleName, fInputInstanceName, fInputProcessName, waveHandle);
    raw::TimeStamp_t tempTimeStamp;
    int PMTPerBoard = 15;
    int NumPMT = fTotalCAENBoards*PMTPerBoard; //15 baords per CAEN is fixed
    int NumFlash = (*waveHandle).size()/NumPMT;
    std::unique_ptr< std::vector< raw::OpDetWaveform > > summedWvfmVec(std::make_unique< std::vector< raw::OpDetWaveform > > ());
    //loop over flashes
    for(int FlashCounter=0; FlashCounter<NumFlash; FlashCounter++)
    {
        //Start a new summed wvfm for this flash
        std::vector<int> summedWvfm(5000);
        //Loop over each CAEN board
        for(int CurrentBoard=0; CurrentBoard<fTotalCAENBoards; CurrentBoard++)
        {
            //Loop over each PMT in a board
            for(int CAENChannel=0; CAENChannel<PMTPerBoard; CAENChannel++)
            {
                //To move to the next flash in a given CAEN we need to shift forward by 15 PMT
                //To move to the next board we have to shift forward by 15 PMT*Number flash
                //To move to next PMT we have to shift forward by 1
                //I think ARAPUCA live in their own object? I hope so
                int MinNextStart=-1;
                int Index = CAENChannel + FlashCounter*PMTPerBoard + CurrentBoard*PMTPerBoard*NumFlash;
                auto const& wvf = (*waveHandle)[Index];
                tempTimeStamp = wvf.TimeStamp();
                //Throw out non-pmt channels. Can make this more robust later
                int fChNumber = wvf.ChannelNumber(); //Get the channel number for this waveform
                if(fChNumber>899) continue; //copy of trigger in signal doesn't need to be analyzed. 899 is for commissioning test
                std::string opdetType = pdMap.pdType(fChNumber);
                if (std::find(fOpDetsToPlot.begin(), fOpDetsToPlot.end(), opdetType) == fOpDetsToPlot.end()) {continue;}
                //Sometimes flashes are longer than 5000 samples because of retrigger
                if(wvf.size() != summedWvfm.size()) summedWvfm.resize(wvf.size()); 
                //Loop through samples of channel waveforms
                int j=1;
                fBaselineValue=GetWaveformMedian(wvf); //Can comment out later
                while(j<int(wvf.size()))
                {
                    if( (wvf[j]-fBaselineValue <= fSummingThreshold) && (wvf[j-1]-fBaselineValue > fSummingThreshold) )
                    {
                        int StartIndex = j-fSummingWindow;
                        //Prevent addition of some samples multiple times
                        if(StartIndex<MinNextStart) StartIndex=MinNextStart;
                        int EndIndex = j+fSummingWindow;
                        //handle bounds errors
                        if(StartIndex<0) StartIndex=0;
                        if(EndIndex>=int(wvf.size())) EndIndex=wvf.size()-1;
                        for(int k=StartIndex; k<=EndIndex; k++)
                        {
                            summedWvfm[k] = summedWvfm[k] + wvf[k] - fBaselineValue;
                        }
                        MinNextStart=EndIndex + 1;
                        j = EndIndex + 1; //should add a tracker for last start
                    }
                    else j=j+1;
                } //Loop over waveform index
            } //Loop over channels
        } //Loop over board
        // End of flash so copy the summed waveform into our vector
        std::vector<uint16_t> summedWvfm_CorrectFormat(summedWvfm.size());
        for(int k=0; k<int(summedWvfm.size()); k++)
        {
            summedWvfm_CorrectFormat[k] = summedWvfm[k] + 29000;
        }
        unsigned int tempChannel = 9999;
        raw::OpDetWaveform summedWvfmObject(tempTimeStamp, tempChannel, summedWvfm_CorrectFormat);
        summedWvfmVec->push_back(summedWvfmObject);
    }
    //Put summed waveform into event
    evt.put(std::move(summedWvfmVec),fch_instance_name); 
}

  double ZeroSurpressedPMTSummer::GetWaveformMedian(raw::OpDetWaveform wvf)
  {
    std::sort(wvf.begin(), wvf.end());
    int MedianIndex = int(wvf.size()/2);
    return wvf[MedianIndex];
  }
DEFINE_ART_MODULE(ZeroSurpressedPMTSummer)