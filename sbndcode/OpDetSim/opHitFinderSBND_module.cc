////////////////////////////////////////////////////////////////////////
// Class:       opHitFinderSBND
// Module Type: producer
// File:        opHitFinderSBND_module.cc
//
// This module produces an OpHit object for light analysis
// Created by L. Paulucci and F. Marinho
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"

#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
//#include "larana/OpticalDetector/OpHitFinder/OpHitAlg.h"
//#include "lardataobj/Simulation/BeamGateInfo.h"

#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
//#include "larsim/MCCheater/PhotonBackTracker.h"

#include <memory>
#include <algorithm>
#include <vector>
#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"

#include "sbndcode/OpDetSim/sbndPDMapAlg.h"

namespace opdet {

  class opHitFinderSBND;

  class opHitFinderSBND : public art::EDProducer {
  public:
    explicit opHitFinderSBND(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    opHitFinderSBND(opHitFinderSBND const &) = delete;
    opHitFinderSBND(opHitFinderSBND &&) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND const &) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;
    opdet::sbndPDMapAlg map; //map for photon detector types

  private:

    // Declare member data here.
    std::string fInputModuleName;
    //  art::ServiceHandle<cheat::PhotonBackTracker> pbt;
    double fSampling; //in MHz
    double fBaselineSample; //in ticks
    double fUseDenoising;
    double fPulsePolarityPMT;
    double fPulsePolarityArapuca;
    double fSaturation; //in number of p.e.
    double fArea1pePMT; //area of 1 pe in ADC*ns for PMTs
    double fArea1peSiPM; //area of 1 pe in ADC*ns for Arapucas
    int fThresholdPMT; //in ADC
    int fThresholdArapuca; //in ADC
    int fEvNumber;
    int fChNumber;
    std::vector<double> fwaveform;
    std::vector<double> outwvform;
    //int fSize;
    //int fTimePMT;         //Start time of PMT signal
    //int fTimeMax;         //Time of maximum (minimum) PMT signal
    void subtractBaseline(std::vector<double>& waveform, std::string pdtype, double& rms);
    bool findPeak(std::vector<double>& waveform, size_t& time, double& Area, double rms, double& amplitude, std::string type);
    void denoise(std::vector<double>& waveform, std::vector<double>& outwaveform);
    bool TV1D_denoise(std::vector<double>& waveform, std::vector<double>& outwaveform, const double lambda);
    //std::stringstream histname;
  };

  opHitFinderSBND::opHitFinderSBND(fhicl::ParameterSet const & p)
    : EDProducer{p}
      // Initialize member data here.
  {
    fInputModuleName = p.get< std::string >("InputModule" );
    fBaselineSample  = p.get< int    >("BaselineSample"); //in ticks
    fSaturation      = p.get< double >("Saturation"   ); //in number of p.e.
    fArea1pePMT      = p.get< double >("Area1pePMT"   ); //in ADC*ns for PMTs
    fArea1peSiPM     = p.get< double >("Area1peSiPM"  ); //in ADC*ns for SiPMs
    fThresholdPMT    = p.get< double >("ThresholdPMT" ); //in ADC
    fThresholdArapuca = p.get< double >("ThresholdArapuca"); //in ADC
    fUseDenoising     = p.get< int   >("UseDenoising");
    fPulsePolarityPMT = p.get< int   >("PulsePolarityPMT");
    fPulsePolarityArapuca = p.get< int   >("PulsePolarityArapuca");

    auto const *timeService = lar::providerFrom< detinfo::DetectorClocksService >();
    fSampling = (timeService->OpticalClock().Frequency()); // MHz
    //    fSampling = (timeService->OpticalClock().Frequency())/1000.0; // GHz

    // Call appropriate produces<>() functions here.
    produces<std::vector<recob::OpHit>>();
  }

  void opHitFinderSBND::produce(art::Event & e)
  {
    // Implementation of required member function here.
    fEvNumber = e.id().event();
    std::cout << "Event #" << fEvNumber << std::endl;

    std::unique_ptr< std::vector< recob::OpHit > > pulseVecPtr(std::make_unique< std::vector< recob::OpHit > > ());
    fwaveform.reserve(30000); // TODO: no hardcoded value
    outwvform.reserve(30000); // TODO: no hardcoded value

    art::ServiceHandle<art::TFileService> tfs;
    art::Handle< std::vector< raw::OpDetWaveform > > wvfHandle;
    std::vector<art::Ptr<raw::OpDetWaveform>> wvfList;
    if(e.getByLabel(fInputModuleName, wvfHandle))
      art::fill_ptr_vector(wvfList, wvfHandle);

    if(!wvfHandle.isValid()) {
      std::cout << Form("Did not find any waveform") << std::endl;
    }

    size_t timebin = 0;
    double FWHM = 1, Area = 0, phelec, fasttotal = 3. / 4., rms = 0, amplitude = 0, time = 0;
    unsigned short frame = 1;
    //int histogram_number = 0;
    for(auto const& wvf_P : wvfList) {
      auto const& wvf = *wvf_P;
      if (wvf.size() == 0 ) {
        std::cout << "Empty waveform, continue." << std::endl;
        continue;
      }

      fChNumber = wvf.ChannelNumber();
      fwaveform.resize(wvf.size());
      for(unsigned int i = 0; i < wvf.size(); i++) {
        fwaveform[i] = wvf[i];
      }

      subtractBaseline(fwaveform, map.pdName(fChNumber), rms);

      if(fUseDenoising == 1) {
        if((map.pdName(fChNumber) == "pmt") || (map.pdName(fChNumber) == "barepmt")) {
        }
        else if((map.pdName(fChNumber) == "arapucaT1") || (map.pdName(fChNumber) == "arapucaT2")) {
          denoise(fwaveform, outwvform);
        }
        else if((map.pdName(fChNumber) == "xarapucaT1") || (map.pdName(fChNumber) == "xarapucaT2")) {
          denoise(fwaveform, outwvform);
        }
        else {
          std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber)
                    << ", continue." << std::endl;
          std::terminate();
        }
      }

      int i = 1;
      while(findPeak(fwaveform, timebin, Area, rms, amplitude, map.pdName(fChNumber))) {
        time = wvf.TimeStamp() + (double)timebin / fSampling;

        if(map.pdName(fChNumber) == "pmt" || map.pdName(fChNumber) == "barepmt") {
          phelec = Area / fArea1pePMT;
        }
        else if((map.pdName(fChNumber) == "arapucaT1") || (map.pdName(fChNumber) == "arapucaT2")) {
          phelec = Area / fArea1peSiPM;
        }
        else if((map.pdName(fChNumber) == "xarapucaT1") || (map.pdName(fChNumber) == "xarapucaT2")) {
          phelec = Area / fArea1peSiPM;
        }
        else {
          std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber)
                    << ", continue." << std::endl;
          continue;
        }

        i++;
        //including hit info: OpChannel, PeakTime, PeakTimeAbs, Frame, Width, Area, PeakHeight, PE, FastToTotal
        recob::OpHit opHit(fChNumber, time, time, frame, FWHM, Area, amplitude, phelec, fasttotal);
        pulseVecPtr->emplace_back(opHit);
      } // while findPeak()
      //     histogram_number += 1;
      // fwaveform.clear();
    } // for(auto const& wvf : (*wvfHandle)){

    e.put(std::move(pulseVecPtr));
    std::vector<double>().swap(fwaveform); // clear and release the memory of fwaveform
    std::vector<double>().swap(outwvform); // clear and release the memory of outwvform
  } // void opHitFinderSBND::produce(art::Event & e)

  DEFINE_ART_MODULE(opHitFinderSBND)

  void opHitFinderSBND::subtractBaseline(std::vector<double>& waveform, std::string pdtype, double& rms)
  {
    double baseline = 0.0;
    rms = 0.0;
    int cnt = 0;
    for(int i = 0; i < fBaselineSample; i++) {
      baseline += waveform[i];
      rms += pow(waveform[i], 2.0);
      cnt++;
    }

    baseline = baseline / cnt;
    rms = sqrt(rms / cnt - baseline * baseline);
    rms = rms / sqrt(cnt - 1);

    if(pdtype == "pmt" || pdtype == "barepmt") {
      for(unsigned int i = 0; i < waveform.size(); i++) waveform[i] = fPulsePolarityPMT * (waveform[i] - baseline);
    }
    else if((map.pdName(fChNumber) == "arapucaT1") || (map.pdName(fChNumber) == "arapucaT2")) {
      for(unsigned int i = 0; i < waveform.size(); i++) waveform[i] = fPulsePolarityArapuca * (waveform[i] - baseline);
    }
    else if((map.pdName(fChNumber) == "xarapucaT1") || (map.pdName(fChNumber) == "xarapucaT2")) {
      for(unsigned int i = 0; i < waveform.size(); i++) waveform[i] = fPulsePolarityArapuca * (waveform[i] - baseline);
    }
    else {
      std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber) << std::endl;
      return;
    }
  }

  bool opHitFinderSBND::findPeak(std::vector<double>& waveform, size_t& time, double& Area, double rms, double& amplitude, std::string type)
  {

    //Gets info from highest peak and suppress it
    double aux = *max_element(waveform.begin(), waveform.end());
    double max;
    size_t time_end, bin, binmax = distance(waveform.begin(), max_element(waveform.begin(), waveform.end()));
    int threshold;
    Area = 0;

    if(type == "pmt" || type == "barepmt") {
      threshold = fThresholdPMT;
    }
    else if((map.pdName(fChNumber) == "arapucaT1") || (map.pdName(fChNumber) == "arapucaT2")) {
      threshold = fThresholdArapuca;
    }
    else if((map.pdName(fChNumber) == "xarapucaT1") || (map.pdName(fChNumber) == "xarapucaT2")) {
      threshold = fThresholdArapuca;
    }
    else {
      std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber) << std::endl;
      return false;
    }

    bin = binmax;
    amplitude = aux;
    max = aux;

    if(aux < threshold) return false;

    while(aux >= threshold) {
      bin++;
      if(bin > waveform.size() - 1) break;
      aux = waveform[bin];
    }
    time_end = bin - 1; //looking for the length of the peak

    aux = max;
    bin = binmax;
    while(aux >= threshold) {
      bin--;
      if((int)bin < 0) break;
      aux = waveform[bin];
    }
    time = bin + 1; //for rise time
    for(unsigned int j = time; j <= time_end; j++) Area += waveform[j];
    Area = Area / fSampling;

    bin = time;
    aux = waveform[time];

    while(aux >= threshold) {
      waveform[bin] = 0.0;
      bin++;
      if(bin > waveform.size() - 1) break;
      aux = waveform[bin];
    }
    //std::cout << time << " " << time_end << " " << (time_end - time);
    time = binmax; //returning the peak time
    return true;
  }

  void opHitFinderSBND::denoise(std::vector<double>& waveform, std::vector<double>& outwaveform)
  {

    int wavelength = waveform.size();
    outwaveform = waveform;  // copy
    double lambda = 10.0;
    const uint retries = 5; uint try_ = 0;
    if (wavelength > 0) {
      while (try_ <= retries) {
        if (TV1D_denoise(waveform, outwaveform, lambda)) break;
        try_++;
        mf::LogInfo("opHitFinder") << try_ << "/" << retries
                                   << " Coming out of TV1D_denoise() unsuccessfully, "
                                   << "using lambda: " << lambda;
        lambda += 0.1 * lambda;
        if (try_ == retries) mf::LogWarning("opHitFinder") <<  "Couldn't denoise!";
      }
    }

    for(int i = 0; i < wavelength; i++) {
      if(outwaveform[i]) waveform[i] = outwaveform[i];
    }
  } // void opHitFinderSBND::denoise()

  // TODO: this function is not robust, check if the expected input is given and put exceptions
  bool opHitFinderSBND::TV1D_denoise(std::vector<double>& waveform, std::vector<double>& outwaveform, const double lambda)
  {
    int width = waveform.size();
    int k = 0, k0 = 0; // k: current sample location, k0: beginning of current segment
    double umin = lambda, umax = -lambda; // u is the dual variable
    double vmin = waveform[0] - lambda, vmax = waveform[0] + lambda; // bounds for the segment's value
    int kplus = 0, kminus = 0; // last positions where umax=-lambda, umin=lambda, respectively
    const double twolambda = 2.0 * lambda; // auxiliary variable
    const double minlambda = -lambda; // auxiliary variable
    for (;;) { // simple loop, the exit test is inside
      while (k == width - 1) { // we use the right boundary condition
        if (umin < 0.0) { // vmin is too high -> negative jump necessary
          do outwaveform[k0++] = vmin; while (k0 <= kminus);
          umax = (vmin = waveform[kminus = k = k0]) + (umin = lambda) - vmax;
        }
        else if (umax > 0.0) { // vmax is too low -> positive jump necessary
          do outwaveform[k0++] = vmax; while (k0 <= kplus);
          umin = (vmax = waveform[kplus = k = k0]) + (umax = minlambda) - vmin;
        }
        else {
          vmin += umin / (k - k0 + 1);
          do outwaveform[k0++] = vmin; while(k0 <= k);
          return true;
        }
      } // while (k == width - 1)
      if ((umin += waveform[k + 1] - vmin) < minlambda) { // negative jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmin; while (k0 <= kminus);
        vmax = (vmin = waveform[kplus = kminus = k = k0]) + twolambda;
        umin = lambda; umax = minlambda;
      }
      else if ((umax += waveform[k + 1] - vmax) > lambda) { // positive jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmax; while (k0 <= kplus);
        vmin = (vmax = waveform[kplus = kminus = k = k0]) - twolambda;
        umin = lambda; umax = minlambda;
      }
      else {   //no jump necessary, we continue
        k++;
        if (k > width) return false;
        if (umin >= lambda) { // update of vmin
          vmin += (umin - lambda) / ((kminus = k) - k0 + 1);
          umin = lambda;
        }
        if (umax <= minlambda) { // update of vmax
          vmax += (umax + lambda) / ((kplus = k) - k0 + 1);
          umax = minlambda;
        }
      }
    } // for (;;)
  } // void opHitFinderSBND::TV1D_denoise()

} // namespace opdet
