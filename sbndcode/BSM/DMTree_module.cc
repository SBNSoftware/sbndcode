////////////////////////////////////////////////////////////////////////
// Class:       DMTree
// Module Type: analyzer
// File:        DMTree_module.cc
// Date: 1Feb2022, Author: Supraja Balasubramanian
// LArSoft Analyzer module to make ROOT NTuples with all variables relevant for DM scattering and decay analysis.
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "art_root_io/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Utilities/ToolMacros.h"

#include "fhiclcpp/ParameterSet.h"
#include "fhiclcpp/types/Atom.h"

#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/Wrapper.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindOne.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "canvas/Persistency/Common/Ptr.h"

#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Slice.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "larreco/RecoAlg/EMShowerAlg.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"

#include "larevt/SpaceChargeServices/SpaceChargeService.h"
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeProvider.h"
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeService.h"

#include "larsim/MCCheater/ParticleInventoryService.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larsim/Utils/TruthMatchUtils.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/Utilities/UtilException.h"
#include "lardata/ArtDataHelper/MVAReader.h"
#include "lardataalg/DetectorInfo/DetectorProperties.h"

#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCGeneratorInfo.h"
#include "nusimdata/SimulationBase/MCNeutrino.h"

#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larcoreobj/SummaryData/POTSummary.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/CryostatGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "larcorealg/Geometry/TPCGeo.h"

#include "larpandora/LArPandoraEventBuilding/LArPandoraShower/Tools/IShowerTool.h"

#include "sbnobj/Common/Reco/SimpleFlashMatchVars.h"
#include "sbnobj/Common/Reco/CRUMBSResult.h"

#include "time.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <vector>
#include <climits>
#include <tuple>

#include "TGeoMatrix.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TTree.h"
#include "TH1F.h"
#include "TH1D.h"
#include "TH1I.h"
#include "TH2F.h"
#include "TF1.h"
#include "TEfficiency.h"
#include "TGraphAsymmErrors.h"
#include <TMath.h>
#include <TLorentzVector.h>
#include <vector>

#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

using namespace std;

class DMTree;

class DMTree : public art::EDAnalyzer {
public:
  explicit DMTree(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  DMTree(DMTree const &) = delete;
  DMTree(DMTree &&) = delete;
  DMTree & operator = (DMTree const &) = delete;
  DMTree & operator = (DMTree &&) = delete;
  
  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void endSubRun(art::SubRun const & sr) override;
  void endJob() override;

  //  void GetMaps(art::Event const& e, std::map<int, int> &trackIDToGenMap, std::map<int, std::string> &genTypeMap);
  // void GetTruthMatching(art::Event const& e, const std::vector<art::Ptr<recob::Hit> > &sliceHits, const std::vector<art::Ptr<recob::Hit> > &allHits, std::map<int, int> &trackIDToGenMap, int &matchedID, double &purity, double &completeness);
  art::Ptr<simb::MCTruth> GetSliceTruthMatchHits(
                         const detinfo::DetectorClocksData &clockData,
                         const std::vector<art::Ptr<recob::Hit>> &sliceHits,
                         const std::map<int, art::Ptr<simb::MCTruth>> &particleTruthMap,
                         const std::map<art::Ptr<simb::MCTruth>, int> &truthHitMap,
                         float &completeness, float &purity);

  std::map<art::Ptr<simb::MCTruth>, int> GetTruthHitMap(
		 const detinfo::DetectorClocksData &clockData,
                 const sim::ParticleList &trueParticlesMap,
                 const std::map<int, art::Ptr<simb::MCTruth>> &particleTruthMap,
                 const std::vector<art::Ptr<recob::Hit>> &allHits);
  double showerEnergy(int plane, std::vector<art::Ptr<recob::Hit>> hits);
  double recoEnergy(const detinfo::DetectorClocksData& clockData,const detinfo::DetectorPropertiesData& detProp,const std::vector<art::Ptr<recob::Hit>>& hits,const geo::PlaneID::PlaneID_t plane) const;
  double LifetimeCorrection(detinfo::DetectorClocksData const& clock_data,detinfo::DetectorPropertiesData const& det_prop,double const time,double const T0) const;

  struct Config {
    using Name=fhicl::Name;
    using Comment=fhicl::Comment;
    fhicl::Atom<int> CaloLifeTimeForm{Name("CaloLifeTimeForm"), Comment("0 = exponential, 1 = exponential + constant"), 0};
  };

  explicit DMTree(const Config& config);

  private:
  Config _conf;
  int _CaloLifeTimeForm;
  art::ServiceHandle<cheat::BackTrackerService> bt_serv;
  std::string fHitLabel, fGenieGenModuleLabel;
  art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  art::InputTag fMCTruthTag;
  art::InputTag fMCParticleTag;
  art::InputTag fTrackTag;
  art::InputTag fCaloTag;
  art::InputTag fVertexTag;
  art::InputTag fShowerTag;
  art::InputTag fClusterTag;
  art::InputTag fHitTag;
  art::InputTag fSliceTag;
  art::InputTag fPFParticleTag;
  art::InputTag fPFParticleMetadataTag;
  art::InputTag fFlashMatchTag;
  art::InputTag fCRTTrackMatchTag;
  art::InputTag fCRTHitMatchTag;
  art::InputTag fCrumbsTag;

  //EVENT TYPE
  bool fIsDMe;
  bool fIsBNBnuCos;
  bool fIsCosmic;

  int nnumucc;
  int nnotnumucc;
  int ntotal;
  int nnuescatter;

  //TREES
  TTree* _tree;
  int _run;
  int _subRun;
  int _event;
  double _pot;
  
  TTree* _eventtree;

  //Event information
  int _fRun;
  int _fSubRun;
  int _fEvent;
  
  //SM neutrino truth information
  int _fNuPDG;
  int _fNuCCNC;
  int _fNuMode;
  double _fNuEnergy;
  double _fNuVtxX;
  double _fNuVtxY;
  double _fNuVtxZ;

    
  //DM truth information
  int _fDMPDG;
  double _fDMVx;
  double _fDMVy;
  double _fDMVz;
  double _fDMEndX;
  double _fDMEndY;
  double _fDMEndZ;
  double _fDMPx;
  double _fDMPy;
  double _fDMPz;
  double _fDME;
  double _fDMP;
  double _fDMPt;
  
  // Event Selection Variables
  std::vector<double> _fMCcostheta;

  //MCparticle truth information per event
  int _fNMCParticles;
  std::vector<int> _fMCParticlePdgCode;
  std::vector<int> _fMCParticleTrackId;
  std::vector<int> _fMCParticleStatusCode;
  std::vector<int> _fMCParticleMother;
  std::vector<std::string> _fMCParticleProcess;
  std::vector<int> _fMCParticleNumberDaughters;
  std::vector<double> _fMCParticleVx;
  std::vector<double> _fMCParticleVy;
  std::vector<double> _fMCParticleVz;
  std::vector<double> _fMCParticleT;
  std::vector<double> _fMCParticleEndX;
  std::vector<double> _fMCParticleEndY;
  std::vector<double> _fMCParticleEndZ;
  std::vector<double> _fMCParticleEndT;
  std::vector<double> _fMCParticlePx;
  std::vector<double> _fMCParticlePy;
  std::vector<double> _fMCParticlePz;
  std::vector<double> _fMCParticleE;
  std::vector<double> _fMCParticleM;
  std::vector<double> _fMCParticleP;
  std::vector<double> _fMCParticlePt;

  //Reconstructed objects per event
  int _fNHitsU;
  int _fNHitsV;
  int _fNHitsY;
  int _fNClustersU;
  int _fNClustersV;
  int _fNClustersY;
  int _fNClusters;
  int _fNShowers;
  int _fNVertices;
  int _fNTracks;
  int _fNPFParticles;
  int _fNSlices;
  int _fNSlicesCosmic;
  int _fNSlicesPdgCode11;
  int _fNSlicesPdgCode12;
  int _fNSlicesPdgCode14;
  int _fNSlicesPdgCodeOther;

  //Reco slices
  std::vector<int> _fSlicePdgCode;
  std::vector<int> _fSliceNPFParticles;
  std::vector<int> _fSliceNTracks;
  std::vector<int> _fSliceNShowers;
  std::vector<int> _fSliceNClusters;
  std::vector<int> _fSliceNClustersU;
  std::vector<int> _fSliceNClustersV;
  std::vector<int> _fSliceNClustersY;
  std::vector<int> _fSliceNHitsU;
  std::vector<int> _fSliceNHitsV;
  std::vector<int> _fSliceNHitsY;
  std::vector<double> _fSliceNuScore;
  std::vector<double> _fSliceFMScore;
  std::vector<double> _fSliceFMPE;
  std::vector<double> _fSliceFMTime;
  std::vector<double> _fSliceCRTTrackScore;
  std::vector<double> _fSliceCRTHitScore;
  std::vector<double> _fSliceCRTTrackTime;
  std::vector<double> _fSliceCRTHitTime;

  //Crumbs variables
  std::vector<float> _fSliceCrumbsScore;
  std::vector<float> _ftpc_CRFracHitsInLongestTrack;
  std::vector<float> _ftpc_CRLongestTrackDeflection;
  std::vector<float> _ftpc_CRLongestTrackDirY;
  std::vector<int> _ftpc_CRNHitsMax;
  std::vector<float> _ftpc_NuEigenRatioInSphere;
  std::vector<int> _ftpc_NuNFinalStatePfos;
  std::vector<int> _ftpc_NuNHitsTotal;
  std::vector<int> _ftpc_NuNSpacePointsInSphere;
  std::vector<float> _ftpc_NuVertexY;
  std::vector<float> _ftpc_NuWeightedDirZ;
  std::vector<float> _ftpc_StoppingChi2CosmicRatio;
  std::vector<float> _fpds_FMTotalScore;
  std::vector<float> _fpds_FMPE;
  std::vector<float> _fpds_FMTime;
  std::vector<float> _fcrt_TrackScore;
  std::vector<float> _fcrt_HitScore;
  std::vector<float> _fcrt_TrackTime;
  std::vector<float> _fcrt_HitTime;
  
 
  //Reco hits
  std::vector<int> _fHitPlane;
  std::vector<int> _fHitCryostat;
  std::vector<int> _fHitTPC;
  std::vector<int> _fHitWire;
  std::vector<double> _fHitIntegral;
  std::vector<double> _fHitSummedADC;
  std::vector<double> _fHitPeakAmplitude;
  std::vector<double> _fHitPeakTime;
  std::vector<double> _fHitRMS;
  std::vector<double> _fHitStartTick;
  std::vector<double> _fHitEndTick;

  //Reco clusters
  std::vector<int> _fClusterPlane;
  std::vector<int> _fClusterNHits;
  std::vector<double> _fClusterSummedADC;
  std::vector<double> _fClusterIntegral;
  std::vector<int> _fClusterStartWire;
  std::vector<int> _fClusterEndWire;
  std::vector<double> _fClusterStartTick;
  std::vector<double> _fClusterEndTick;

  //Reco vertex
  std::vector<int> _fVertexID;
  std::vector<double> _fVertexX;
  std::vector<double> _fVertexY;
  std::vector<double> _fVertexZ;

  //Reco showers
  std::vector<int> _fShowerID;
  std::vector<double> _fShowerDirX;
  std::vector<double> _fShowerDirY;
  std::vector<double> _fShowerDirZ;
  std::vector<double> _fShowerStartX;
  std::vector<double> _fShowerStartY;
  std::vector<double> _fShowerStartZ;
  std::vector<int> _fShowerBestPlane;
  std::vector<double> _fShowerLength;
  std::vector<double> _fShowerOpenAngle;
  std::vector<double> _fShowerEnergy;

  //Reco tracks
  std::vector<double> _fTrackVertexX;
  std::vector<double> _fTrackVertexY;
  std::vector<double> _fTrackVertexZ;
  std::vector<double> _fTrackEndX;
  std::vector<double> _fTrackEndY;
  std::vector<double> _fTrackEndZ;
  std::vector<double> _fTrackVertexDirX;
  std::vector<double> _fTrackVertexDirY;
  std::vector<double> _fTrackVertexDirZ;
  std::vector<double> _fTrackEndDirX;
  std::vector<double> _fTrackEndDirY;
  std::vector<double> _fTrackEndDirZ;
  std::vector<double> _fTrackLength;
  std::vector<int> _fTrackParticleId;
  std::vector<double> _fTrackTheta;
  std::vector<double> _fTrackPhi;
  std::vector<double> _fTrackEnergy;

  
  //DETECTOR SERVICES
  detinfo::DetectorProperties const * theDetector ;// = lar::providerFrom<detinfo::DetectorPropertiesService>();
  detinfo::DetectorClocks    const *  detClocks   ;//= lar::providerFrom<detinfo::DetectorClocksService>();
  spacecharge::SpaceCharge const * SCE;
  //geo::GeometryCore const * geom;
  // art::ServiceHandle<geo::Geometry> fGeom;
 
 
};


//////////////////// FHICL PARAMETER TAGS //////////////////////////////
DMTree::DMTree(fhicl::ParameterSet const & p) : EDAnalyzer(p){
  fMCTruthTag = p.get<std::string>("MCTruthProducer");
  fMCParticleTag = p.get<std::string>("MCParticleProducer");
  fVertexTag = p.get<std::string>("VertexProducer");
  fShowerTag = p.get<std::string>("ShowerProducer");
  fClusterTag = p.get<std::string>("ClusterProducer");
  fTrackTag = p.get<std::string>("TrackProducer");
  fCaloTag = p.get<std::string>("CaloProducer");
  fHitTag = p.get<std::string>("HitProducer");
  fSliceTag = p.get<std::string>("SliceProducer");
  fPFParticleTag = p.get<std::string>("PFParticleProducer");
  fPFParticleMetadataTag = p.get<std::string>("PFParticleMetadataProducer");
  fFlashMatchTag = p.get<std::string>("FlashMatchProducer");
  fCRTTrackMatchTag = p.get<std::string>("CRTTrackMatchProducer");
  fCRTHitMatchTag = p.get<std::string>("CRTHitMatchProducer");
  fCrumbsTag = p.get<std::string>("CrumbsProducer");
  fIsBNBnuCos = p.get<bool>("IsBNBnuCos",true);
  fIsDMe = p.get<bool>("IsDMe",true);
  fIsCosmic = p.get<bool>("IsCosmic",true);
  //theDetector = lar::providerFrom<detinfo::DetectorPropertiesService>();
  //detClocks   = lar::providerFrom<detinfo::DetectorClocksService>();
  //  SCE = lar::providerFrom<spacecharge::SpaceChargeService>();
  //  geom = lar::providerFrom<geo::Geometry>();
}//Fhicl parameter tags

void DMTree::beginJob()  {

  art::ServiceHandle<art::TFileService> tfs;

  nnumucc = 0;
  nnotnumucc = 0;
  ntotal = 0;
  nnuescatter = 0;
  
  _tree = 0;
  if(!_tree){
    _tree = tfs->make<TTree>("tree","tree");
    _tree->Branch("run",&_run,"run/I");
    _tree->Branch("subRun",&_subRun,"subRun/I");
    _tree->Branch("event",&_event,"event/I");
    _tree->Branch("pot",&_pot,"pot/D");
  }//tree
  
  _run = 0;
  _subRun = 0;
  _pot = 0;

  _eventtree = 0;
  if(!_eventtree){
    _eventtree = tfs->make<TTree>("eventtree","eventtree");

    //Event information
    _eventtree->Branch("_fRun",&_fRun,"_fRun/I");
    _eventtree->Branch("_fSubRun",&_fSubRun,"_fSubRun/I");
    _eventtree->Branch("_fEvent",&_fEvent,"_fEvent/I");
    
    //Truth information
    _eventtree->Branch("_fNuCCNC",&_fNuCCNC,"_fNuCCNC/I");
    _eventtree->Branch("_fNuMode",&_fNuMode,"_fNuMode/I");
    _eventtree->Branch("_fNuEnergy",&_fNuEnergy,"_fNuEnergy/D");
    _eventtree->Branch("_fNuVtxX",&_fNuVtxX,"_fNuVtxX/D");
    _eventtree->Branch("_fNuVtxY",&_fNuVtxY,"_fNuVtxY/D");
    _eventtree->Branch("_fNuVtxZ",&_fNuVtxZ,"_fNuVtxZ/D");
    _eventtree->Branch("_fNuPDG",&_fNuPDG,"_fNuPDG/I");
    
    _eventtree->Branch("_fDMPDG",&_fDMPDG,"_fDMPDG/I");
    _eventtree->Branch("_fDMVx",&_fDMVx,"_fDMVx/D");
    _eventtree->Branch("_fDMVy",&_fDMVy,"_fDMVy/D");
    _eventtree->Branch("_fDMVz",&_fDMVz,"_fDMVz/D");
    _eventtree->Branch("_fDMEndX",&_fDMEndX,"_fDMEndX/D");
    _eventtree->Branch("_fDMEndY",&_fDMEndY,"_fDMEndY/D");
    _eventtree->Branch("_fDMEndZ",&_fDMEndZ,"_fDMEndZ/D");
    _eventtree->Branch("_fDMPx",&_fDMPx,"_fDMPx/D");
    _eventtree->Branch("_fDMPy",&_fDMPy,"_fDMPy/D");
    _eventtree->Branch("_fDMPz",&_fDMPz,"_fDMPz/D");
    _eventtree->Branch("_fDME",&_fDME,"_fDME/D");
    _eventtree->Branch("_fDMP",&_fDMP,"_fDMP/D");
    _eventtree->Branch("_fDMPt",&_fDMPt,"_fDMPt/D");

    _eventtree->Branch("_fMCcostheta", "std::vector<double>", &_fMCcostheta);

    _eventtree->Branch("_fNMCParticles",&_fNMCParticles,"_fNMCParticles/I");
    _eventtree->Branch("_fMCParticlePdgCode", "std::vector<int>", &_fMCParticlePdgCode);
    _eventtree->Branch("_fMCParticleTrackId", "std::vector<int>", &_fMCParticleTrackId);
    _eventtree->Branch("_fMCParticleStatusCode", "std::vector<int>", &_fMCParticleStatusCode);
    _eventtree->Branch("_fMCParticleMother", "std::vector<int>", &_fMCParticleMother);
    _eventtree->Branch("_fMCParticleProcess", "std::vector<std::string>", &_fMCParticleProcess);
    _eventtree->Branch("_fMCParticleNumberDaughters", "std::vector<int>", &_fMCParticleNumberDaughters);
    _eventtree->Branch("_fMCParticleVx", "std::vector<double>", &_fMCParticleVx);
    _eventtree->Branch("_fMCParticleVy", "std::vector<double>", &_fMCParticleVy);
    _eventtree->Branch("_fMCParticleVz", "std::vector<double>", &_fMCParticleVz);
    _eventtree->Branch("_fMCParticleT", "std::vector<double>", &_fMCParticleT);
    _eventtree->Branch("_fMCParticleEndX", "std::vector<double>", &_fMCParticleEndX);
    _eventtree->Branch("_fMCParticleEndY", "std::vector<double>", &_fMCParticleEndY);
    _eventtree->Branch("_fMCParticleEndZ", "std::vector<double>", &_fMCParticleEndZ);
    _eventtree->Branch("_fMCParticleEndT", "std::vector<double>", &_fMCParticleEndT);
    _eventtree->Branch("_fMCParticlePx", "std::vector<double>", &_fMCParticlePx);
    _eventtree->Branch("_fMCParticlePy", "std::vector<double>", &_fMCParticlePy);
    _eventtree->Branch("_fMCParticlePz", "std::vector<double>", &_fMCParticlePz);
    _eventtree->Branch("_fMCParticleE", "std::vector<double>", &_fMCParticleE);
    _eventtree->Branch("_fMCParticleM", "std::vector<double>", &_fMCParticleM);
    _eventtree->Branch("_fMCParticleP", "std::vector<double>", &_fMCParticleP);
    _eventtree->Branch("_fMCParticlePt", "std::vector<double>", &_fMCParticlePt);

    //Reconstructed information
    _eventtree->Branch("_fNTracks",&_fNTracks,"_fNTracks/I");
    _eventtree->Branch("_fNVertices",&_fNVertices,"_fNVertices/I");
    _eventtree->Branch("_fNShowers",&_fNShowers,"_fNShowers/I");
    _eventtree->Branch("_fNHitsU",&_fNHitsU,"_fNHitsU/I");
    _eventtree->Branch("_fNHitsV",&_fNHitsV,"_fNHitsV/I");
    _eventtree->Branch("_fNHitsY",&_fNHitsY,"_fNHitsY/I");
    _eventtree->Branch("_fNClustersU",&_fNClustersU,"_fNClustersU/I");
    _eventtree->Branch("_fNClustersV",&_fNClustersV,"_fNClustersV/I");
    _eventtree->Branch("_fNClustersY",&_fNClustersY,"_fNClustersY/I");
    _eventtree->Branch("_fNClusters",&_fNClusters,"_fNClusters/I");
    _eventtree->Branch("_fNPFParticles",&_fNPFParticles,"_fNPFParticles/I");
    _eventtree->Branch("_fNSlices",&_fNSlices,"_fNSlices/I");
    _eventtree->Branch("_fNSlicesCosmic",&_fNSlicesCosmic,"_fNSlicesCosmic/I");
    _eventtree->Branch("_fNSlicesPdgCode11",&_fNSlicesPdgCode11,"_fNSlicesPdgCode11/I");
    _eventtree->Branch("_fNSlicesPdgCode12",&_fNSlicesPdgCode12,"_fNSlicesPdgCode12/I");
    _eventtree->Branch("_fNSlicesPdgCode14",&_fNSlicesPdgCode14,"_fNSlicesPdgCode14/I");
    _eventtree->Branch("_fNSlicesPdgCodeOther",&_fNSlicesPdgCodeOther,"_fNSlicesPdgCodeOther/I");

    _eventtree->Branch("_fSlicePdgCode", "std::vector<int>", &_fSlicePdgCode);
    _eventtree->Branch("_fSliceNPFParticles", "std::vector<int>", &_fSliceNPFParticles);
    _eventtree->Branch("_fSliceNTracks", "std::vector<int>", &_fSliceNTracks);
    _eventtree->Branch("_fSliceNShowers", "std::vector<int>", &_fSliceNShowers);
    _eventtree->Branch("_fSliceNClusters", "std::vector<int>", &_fSliceNClusters);
    _eventtree->Branch("_fSliceNClustersU", "std::vector<int>", &_fSliceNClustersU);
    _eventtree->Branch("_fSliceNClustersV", "std::vector<int>", &_fSliceNClustersV);
    _eventtree->Branch("_fSliceNClustersY", "std::vector<int>", &_fSliceNClustersY);
    _eventtree->Branch("_fSliceNHitsU", "std::vector<int>", &_fSliceNHitsU);
    _eventtree->Branch("_fSliceNHitsV", "std::vector<int>", &_fSliceNHitsV);
    _eventtree->Branch("_fSliceNHitsY", "std::vector<int>", &_fSliceNHitsY);
    _eventtree->Branch("_fSliceNuScore", "std::vector<double>", &_fSliceNuScore);
    _eventtree->Branch("_fSliceFMScore", "std::vector<double>", &_fSliceFMScore);
    _eventtree->Branch("_fSliceFMPE", "std::vector<double>", &_fSliceFMPE);
    _eventtree->Branch("_fSliceFMTime", "std::vector<double>", &_fSliceFMTime);
    _eventtree->Branch("_fSliceCRTTrackScore", "std::vector<double>", &_fSliceCRTTrackScore);
    _eventtree->Branch("_fSliceCRTHitScore", "std::vector<double>", &_fSliceCRTHitScore);
    _eventtree->Branch("_fSliceCRTTrackTime", "std::vector<double>", &_fSliceCRTTrackTime);
    _eventtree->Branch("_fSliceCRTHitTime", "std::vector<double>", &_fSliceCRTHitTime);

     _eventtree->Branch("_fSliceCrumbsScore", "std::vector<float>", &_fSliceCrumbsScore);
     _eventtree->Branch("_ftpc_CRFracHitsInLongestTrack", "std::vector<float>", &_ftpc_CRFracHitsInLongestTrack);
     _eventtree->Branch("_ftpc_CRLongestTrackDeflection", "std::vector<float>", &_ftpc_CRLongestTrackDeflection);
     _eventtree->Branch("_ftpc_CRLongestTrackDirY", "std::vector<float>", &_ftpc_CRLongestTrackDirY);
     _eventtree->Branch("_ftpc_CRNHitsMax", "std::vector<int>", &_ftpc_CRNHitsMax);
     _eventtree->Branch("_ftpc_NuEigenRatioInSphere", "std::vector<float>", &_ftpc_NuEigenRatioInSphere);
     _eventtree->Branch("_ftpc_NuNFinalStatePfos", "std::vector<int>", &_ftpc_NuNFinalStatePfos);
     _eventtree->Branch("_ftpc_NuNHitsTotal", "std::vector<int>", &_ftpc_NuNHitsTotal);
     _eventtree->Branch("_ftpc_NuNSpacePointsInSphere", "std::vector<int>", &_ftpc_NuNSpacePointsInSphere);
     _eventtree->Branch("_ftpc_NuVertexY", "std::vector<float>", &_ftpc_NuVertexY);
     _eventtree->Branch("_ftpc_NuWeightedDirZ", "std::vector<float>", &_ftpc_NuWeightedDirZ);
     _eventtree->Branch("_ftpc_StoppingChi2CosmicRatio", "std::vector<float>", &_ftpc_StoppingChi2CosmicRatio);
     _eventtree->Branch("_fpds_FMTotalScore", "std::vector<float>", &_fpds_FMTotalScore);
     _eventtree->Branch("_fpds_FMPE", "std::vector<float>", &_fpds_FMPE);
     _eventtree->Branch("_fpds_FMTime", "std::vector<float>", &_fpds_FMTime);
     _eventtree->Branch("_fcrt_TrackScore", "std::vector<float>", &_fcrt_TrackScore);
     _eventtree->Branch("_fcrt_HitScore", "std::vector<float>", &_fcrt_HitScore);
     _eventtree->Branch("_fcrt_TrackTime", "std::vector<float>", &_fcrt_TrackTime);
     _eventtree->Branch("_fcrt_HitTime", "std::vector<float>", &_fcrt_HitTime);

    _eventtree->Branch("_fHitPlane", "std::vector<int>", &_fHitPlane);
    _eventtree->Branch("_fHitCryostat", "std::vector<int>", &_fHitCryostat);
    _eventtree->Branch("_fHitTPC", "std::vector<int>", &_fHitTPC);
    _eventtree->Branch("_fHitWire", "std::vector<int>", &_fHitWire);
    _eventtree->Branch("_fHitIntegral", "std::vector<double>", &_fHitIntegral);
    _eventtree->Branch("_fHitSummedADC", "std::vector<double>", &_fHitSummedADC);
    _eventtree->Branch("_fHitPeakAmplitude", "std::vector<double>", &_fHitPeakAmplitude);
    _eventtree->Branch("_fHitPeakTime", "std::vector<double>", &_fHitPeakTime);
    _eventtree->Branch("_fHitRMS", "std::vector<double>", &_fHitRMS);
    _eventtree->Branch("_fHitStartTick", "std::vector<double>", &_fHitStartTick);
    _eventtree->Branch("_fHitEndTick", "std::vector<double>", &_fHitEndTick);

    _eventtree->Branch("_fClusterPlane", "std::vector<int>", &_fClusterPlane);
    _eventtree->Branch("_fClusterNHits", "std::vector<int>", &_fClusterNHits);
    _eventtree->Branch("_fClusterSummedADC", "std::vector<double>", &_fClusterSummedADC);
    _eventtree->Branch("_fClusterIntegral", "std::vector<double>", &_fClusterIntegral);
    _eventtree->Branch("_fClusterStartWire", "std::vector<int>", &_fClusterStartWire);
    _eventtree->Branch("_fClusterEndWire", "std::vector<int>", &_fClusterEndWire);
    _eventtree->Branch("_fClusterStartTick", "std::vector<double>", &_fClusterStartTick);
    _eventtree->Branch("_fClusterEndTick", "std::vector<double>", &_fClusterEndTick);
    
    _eventtree->Branch("_fShowerID", "std::vector<int>", &_fShowerID);
    _eventtree->Branch("_fShowerDirX", "std::vector<double>", &_fShowerDirX);
    _eventtree->Branch("_fShowerDirY", "std::vector<double>", &_fShowerDirY);
    _eventtree->Branch("_fShowerDirZ", "std::vector<double>", &_fShowerDirZ);
    _eventtree->Branch("_fShowerStartX", "std::vector<double>", &_fShowerStartX);
    _eventtree->Branch("_fShowerStartY", "std::vector<double>", &_fShowerStartY);
    _eventtree->Branch("_fShowerStartZ", "std::vector<double>", &_fShowerStartZ);
    _eventtree->Branch("_fShowerBestPlane", "std::vector<int>", &_fShowerBestPlane);
    _eventtree->Branch("_fShowerLength", "std::vector<double>", &_fShowerLength);
    _eventtree->Branch("_fShowerOpenAngle", "std::vector<double>", &_fShowerOpenAngle);
    _eventtree->Branch("_fShowerEnergy", "std::vector<double>", &_fShowerEnergy);
    
    _eventtree->Branch("_fVertexID", "std::vector<int>", &_fVertexID);
    _eventtree->Branch("_fVertexX", "std::vector<double>", &_fVertexX);
    _eventtree->Branch("_fVertexY", "std::vector<double>", &_fVertexY);
    _eventtree->Branch("_fVertexZ", "std::vector<double>", &_fVertexZ);

    _eventtree->Branch("_fTrackVertexX", "std::vector<double>", &_fTrackVertexX);
    _eventtree->Branch("_fTrackVertexY", "std::vector<double>", &_fTrackVertexY);
    _eventtree->Branch("_fTrackVertexZ", "std::vector<double>", &_fTrackVertexZ);
    _eventtree->Branch("_fTrackEndX", "std::vector<double>", &_fTrackEndX);
    _eventtree->Branch("_fTrackEndY", "std::vector<double>", &_fTrackEndY);
    _eventtree->Branch("_fTrackEndZ", "std::vector<double>", &_fTrackEndZ);
    _eventtree->Branch("_fTrackVertexDirX", "std::vector<double>", &_fTrackVertexDirX);
    _eventtree->Branch("_fTrackVertexDirY", "std::vector<double>", &_fTrackVertexDirY);
    _eventtree->Branch("_fTrackVertexDirZ", "std::vector<double>", &_fTrackVertexDirZ);
    _eventtree->Branch("_fTrackEndDirX", "std::vector<double>", &_fTrackEndDirX);
    _eventtree->Branch("_fTrackEndDirY", "std::vector<double>", &_fTrackEndDirY);
    _eventtree->Branch("_fTrackEndDirZ", "std::vector<double>", &_fTrackEndDirZ);
    _eventtree->Branch("_fTrackLength", "std::vector<double>", &_fTrackLength);
    _eventtree->Branch("_fTrackParticleId", "std::vector<int>", &_fTrackParticleId);
    _eventtree->Branch("_fTrackTheta", "std::vector<double>", &_fTrackTheta);
    _eventtree->Branch("_fTrackPhi", "std::vector<double>", &_fTrackPhi);
    _eventtree->Branch("_fTrackEnergy", "std::vector<double>", &_fTrackEnergy);

  }//eventtree
  
}//Begin job


void DMTree::analyze(art::Event const & e){

  // Get the MC information
  art::Handle<std::vector<simb::MCTruth>> MCTruthHandle;
  std::vector<art::Ptr<simb::MCTruth>> MCTruthVector;
  if(!fIsCosmic){if (e.getByLabel(fMCTruthTag, MCTruthHandle)){art::fill_ptr_vector(MCTruthVector, MCTruthHandle);}}
  auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataFor(e);
  
  /*
  art::Handle<std::vector<simb::MCTruth>> CosmicTruthHandle;
  std::vector<art::Ptr<simb::MCTruth>> CosmicTruthVector;
  if(!fIsCosmic){if (e.getByLabel(fCosmicTruthTag, CosmicTruthHandle)){art::fill_ptr_vector(CosmicTruthVector, CosmicTruthHandle);}}
  */
  art::Handle<std::vector<simb::MCParticle>> MCParticleHandle;
  std::vector<art::Ptr<simb::MCParticle>> MCParticleVector;
  if (e.getByLabel(fMCParticleTag, MCParticleHandle)){art::fill_ptr_vector(MCParticleVector, MCParticleHandle);}

  //Get the CRUMBS product
  art::Handle<std::vector<sbn::CRUMBSResult>> CrumbsHandle;
  std::vector<art::Ptr<sbn::CRUMBSResult>> CrumbsVector;
  if (e.getByLabel(fCrumbsTag, CrumbsHandle)){art::fill_ptr_vector(CrumbsVector, CrumbsHandle);}

  //Get the reco products
  art::Handle<std::vector<recob::Slice>> SliceHandle;
  std::vector<art::Ptr<recob::Slice>> SliceVector;
  if (e.getByLabel(fSliceTag, SliceHandle)){art::fill_ptr_vector(SliceVector, SliceHandle);}

  art::Handle<std::vector<recob::PFParticle>> PFParticleHandle;
  std::vector<art::Ptr<recob::PFParticle>> PFParticleVector;
  if (e.getByLabel(fPFParticleTag, PFParticleHandle)){art::fill_ptr_vector(PFParticleVector, PFParticleHandle);}
  
  art::Handle<std::vector<recob::Shower>> ShowerHandle;
  std::vector<art::Ptr<recob::Shower>> ShowerVector;
  if (e.getByLabel(fShowerTag, ShowerHandle)){art::fill_ptr_vector(ShowerVector, ShowerHandle);}
    
  art::Handle<std::vector<recob::Vertex>> VertexHandle;
  std::vector<art::Ptr<recob::Vertex>> VertexVector;
  if (e.getByLabel(fVertexTag, VertexHandle)){art::fill_ptr_vector(VertexVector, VertexHandle);}

  art::Handle<std::vector<recob::Cluster>> ClusterHandle;
  std::vector<art::Ptr<recob::Cluster>> ClusterVector;
  if (e.getByLabel(fClusterTag, ClusterHandle)){art::fill_ptr_vector(ClusterVector, ClusterHandle);}

  art::Handle<std::vector<recob::Track>> TrackHandle;
  std::vector<art::Ptr<recob::Track>> TrackVector;
  if (e.getByLabel(fTrackTag, TrackHandle)){art::fill_ptr_vector(TrackVector, TrackHandle);}
  
  art::Handle<std::vector<recob::Hit>> HitHandle;
  std::vector<art::Ptr<recob::Hit>> HitVector;
  if (e.getByLabel("gaushit", HitHandle)){art::fill_ptr_vector(HitVector, HitHandle);}

  art::FindManyP<recob::Hit>  fmshowerhit(ShowerHandle, e, fShowerTag);
  art::FindManyP<recob::Hit>  fmvertexhit(VertexHandle, e, fVertexTag);
  art::FindManyP<recob::Hit>  fmtrackhit(TrackHandle, e, fTrackTag);
  art::FindManyP<recob::Hit>  fmclusterhit(ClusterHandle, e, fClusterTag);
  
  art::FindManyP<recob::Cluster>  fmshowercluster(ShowerHandle, e, fShowerTag);
  art::FindManyP<recob::Cluster>  fmvertexcluster(VertexHandle, e, fVertexTag);

  art::FindManyP<recob::PFParticle> fmshowerpfp(ShowerHandle, e, fShowerTag);
  art::FindManyP<recob::PFParticle> fmvertexpfp(VertexHandle, e, fVertexTag);
  art::FindManyP<recob::Track> fmpfptrack(PFParticleHandle, e, fTrackTag);
  art::FindManyP<recob::Cluster> fmpfpcluster(PFParticleHandle, e, fPFParticleTag);
  art::FindManyP<recob::PFParticle> fmslicepfp(SliceHandle, e, fSliceTag);
  art::FindManyP<recob::Hit>  fmslicehit(SliceHandle, e, fSliceTag);
  
  art::FindManyP<larpandoraobj::PFParticleMetadata> nupfPartToMetaDataAssoc(PFParticleHandle, e, "pandora");
  art::FindManyP<sbn::SimpleFlashMatch> nupfPartToFlashAssoc(PFParticleHandle, e, fFlashMatchTag);

  art::FindManyP<anab::T0> fmtrackcrttrackt0(TrackHandle,e,fCRTTrackMatchTag);
  art::FindManyP<anab::T0> fmtrackcrthitt0(TrackHandle,e,fCRTHitMatchTag);

  art::FindManyP<sbn::CRUMBSResult>  fmslicecrumbs(SliceHandle, e, fCrumbsTag);

  /////// SET TREE VARIABLES TO ZERO ///////

  //Event record
  _fRun = -999;
  _fSubRun = -999;
  _fEvent = -999;

  //Truth information
  _fNuCCNC = -999;
  _fNuMode = -999;
  _fNuEnergy = -999;
  _fNuVtxX = -999;
  _fNuVtxY = -999;
  _fNuVtxZ = -999;
  _fNuPDG = -999;

  _fDMPDG = -999;
  _fDMVx = -999;
  _fDMVy = -999;
  _fDMVz = -999;
  _fDMEndX = -999;
  _fDMEndY = -999;
  _fDMEndZ = -999;
  _fDMPx = -999;
  _fDMPy = -999;
  _fDMPz = -999;
  _fDME = -999;
  _fDMP = -999;
  _fDMPt = -999;

  _fMCcostheta.clear();

  _fMCParticlePdgCode.clear();
  _fMCParticleTrackId.clear();
  _fMCParticleStatusCode.clear();
  _fMCParticleMother.clear();
  _fMCParticleProcess.clear();
  _fMCParticleNumberDaughters.clear();
  _fMCParticleVx.clear();
  _fMCParticleVy.clear();
  _fMCParticleVz.clear();
  _fMCParticleT.clear();
  _fMCParticleEndX.clear();
  _fMCParticleEndY.clear();
  _fMCParticleEndZ.clear();
  _fMCParticleEndT.clear();
  _fMCParticlePx.clear();
  _fMCParticlePy.clear();
  _fMCParticlePz.clear();
  _fMCParticleE.clear();
  _fMCParticleM.clear();
  _fMCParticleP.clear();
  _fMCParticlePt.clear();

  //Reconstructed information
  _fNTracks = -999;
  _fNVertices = -999;
  _fNShowers = -999;
  _fNHitsU = -999;
  _fNHitsV = -999;
  _fNHitsY = -999;
  _fNClustersU = -999;
  _fNClustersV = -999;
  _fNClustersY = -999;
  _fNClusters = -999;
  _fNPFParticles = -999;
  _fNSlices = -999;
  _fNSlicesCosmic = -999;
  _fNSlicesPdgCode11 = -999;
  _fNSlicesPdgCode12 = -999;
  _fNSlicesPdgCode14 = -999;
  _fNSlicesPdgCodeOther = -999;

  //Reco slices
  _fSlicePdgCode.clear();
  _fSliceNPFParticles.clear();
  _fSliceNTracks.clear();
  _fSliceNShowers.clear();
  _fSliceNClusters.clear();
  _fSliceNClustersU.clear();
  _fSliceNClustersV.clear();
  _fSliceNClustersY.clear();
  _fSliceNHitsU.clear();
  _fSliceNHitsV.clear();
  _fSliceNHitsY.clear();
  _fSliceNuScore.clear();
  _fSliceFMScore.clear();
  _fSliceFMPE.clear();
  _fSliceFMTime.clear();
  _fSliceCRTTrackScore.clear();
  _fSliceCRTHitScore.clear();
  _fSliceCRTTrackTime.clear();
  _fSliceCRTHitTime.clear();
  _fSliceCrumbsScore.clear();
  
  _ftpc_CRFracHitsInLongestTrack.clear();
  _ftpc_CRLongestTrackDeflection.clear();
  _ftpc_CRLongestTrackDirY.clear();
  _ftpc_CRNHitsMax.clear();
  _ftpc_NuEigenRatioInSphere.clear();
  _ftpc_NuNFinalStatePfos.clear();
  _ftpc_NuNHitsTotal.clear();
  _ftpc_NuNSpacePointsInSphere.clear();
  _ftpc_NuVertexY.clear();
  _ftpc_NuWeightedDirZ.clear();
  _ftpc_StoppingChi2CosmicRatio.clear();
  _fpds_FMTotalScore.clear();
  _fpds_FMPE.clear();
  _fpds_FMTime.clear();
  _fcrt_TrackScore.clear();
  _fcrt_HitScore.clear();
  _fcrt_TrackTime.clear();
  _fcrt_HitTime.clear();
  
  _fHitPlane.clear();
  _fHitCryostat.clear();
  _fHitTPC.clear();
  _fHitWire.clear();
  _fHitIntegral.clear();
  _fHitSummedADC.clear();
  _fHitPeakAmplitude.clear();
  _fHitPeakTime.clear();
  _fHitRMS.clear();
  _fHitStartTick.clear();
  _fHitEndTick.clear();

  _fClusterPlane.clear();
  _fClusterNHits.clear();
  _fClusterSummedADC.clear();
  _fClusterIntegral.clear();
  _fClusterStartWire.clear();
  _fClusterEndWire.clear();
  _fClusterStartTick.clear();
  _fClusterEndTick.clear();

  _fShowerID.clear();
  _fShowerDirX.clear();
  _fShowerDirY.clear();
  _fShowerDirZ.clear();
  _fShowerStartX.clear();
  _fShowerStartY.clear();
  _fShowerStartZ.clear();
  _fShowerBestPlane.clear();
  _fShowerLength.clear();
  _fShowerOpenAngle.clear();
  _fShowerEnergy.clear();

  _fVertexID.clear();
  _fVertexX.clear();
  _fVertexY.clear();
  _fVertexZ.clear();

  _fTrackVertexX.clear();
  _fTrackVertexY.clear();
  _fTrackVertexZ.clear();
  _fTrackEndX.clear();
  _fTrackEndY.clear();
  _fTrackEndZ.clear();
  _fTrackVertexDirX.clear();
  _fTrackVertexDirY.clear();
  _fTrackVertexDirZ.clear();
  _fTrackEndDirX.clear();
  _fTrackEndDirY.clear();
  _fTrackEndDirZ.clear();
  _fTrackLength.clear();
  _fTrackParticleId.clear();
  _fTrackTheta.clear();
  _fTrackPhi.clear();
  _fTrackEnergy.clear();

  
  
  ///////////////////////////////////////
  /////// RUN SUBRUN EVENT RECORD ///////
  ///////////////////////////////////////
  _fRun = e.run();
  _fSubRun = e.subRun();
  _fEvent = e.event();

  // ///////////////////////////////////////
  // /////// MCTRUTH CHECKS ////////////////
  // ///////////////////////////////////////

  // std::cout<<"Number of MCTruth objects with label generator = "<<MCTruthVector.size()<<" "<<" corsika = "<<CosmicTruthVector.size()<<std::endl;

  // art::FindManyP<simb::MCParticle> MCTMCPAssn(MCTruthHandle,e,fMCParticleTag);
  // art::FindManyP<simb::MCParticle> CosmicTMCPAssn(CosmicTruthHandle,e,fMCParticleTag);

  // for(auto const& mct : MCTruthVector){
  //   std::cout<<"Generator MCTruth loop! Origin = "<<mct->Origin()<<" NParticles = "<<mct->NParticles()<<std::endl;

  //   const std::vector<art::Ptr<simb::MCParticle> > particles = MCTMCPAssn.at(mct.key());

  //   for(auto const& part : particles){
  //     std::cout<<"MCTRUTH PARTICLE! PdgCode = "<<part->PdgCode()<<" Process = "<<part->Process()<<std::endl;
  //   }
    
  // }//mctruth

  // for(auto const& mct : CosmicTruthVector){
  //   std::cout<<"Generator CosmicTruth loop! Origin = "<<mct->Origin()<<" NParticles = "<<mct->NParticles()<<std::endl;

  //   const std::vector<art::Ptr<simb::MCParticle> > particles = CosmicTMCPAssn.at(mct.key());
     
  //   for(auto const& part : particles){
  //     std::cout<<"COSMICTRUTH PARTICLE! PdgCode = "<<part->PdgCode()<<" Process = "<<part->Process()<<std::endl;
  //   }
  // }//cosmictruth

  //////////////////////////////////////////
  //////////// BACKTRACKING ////////////////
  //////////////////////////////////////////
  
  std::map<int, art::Ptr<simb::MCTruth>> particleTruthMap;
  const sim::ParticleList &trueParticlesMap = particleInventory->ParticleList();
  for (auto const &[trackId, particle] : trueParticlesMap) {
    particleTruthMap[trackId] = particleInventory->ParticleToMCTruth_P(particle);
  } // [trackId, particle]: trueParticlesMap
  
  std::vector<art::Ptr<recob::Hit>> allHits;
  if (e.getByLabel("gaushit", HitHandle))
    art::fill_ptr_vector(allHits, HitHandle);

  std::map<art::Ptr<simb::MCTruth>, int> truthHitMap(this->GetTruthHitMap(clockData, trueParticlesMap, particleTruthMap, allHits));
  
  
  /*
  for (const auto &[truth, truthHits] : truthHitMap) {
    
       
  }
  */
  
  //////////////////////////////////////////
  ///////// MCPARTICLE INFORMATION /////////
  //////////////////////////////////////////

  if(!fIsCosmic){

    /////// SM NEUTRINO INFO /////////////////
    if(fIsBNBnuCos){
  
      if(MCTruthVector[0]->NeutrinoSet()){ //neutrino information
	_fNuPDG = MCTruthVector[0]->GetNeutrino().Nu().PdgCode();
	_fNuCCNC = MCTruthVector[0]->GetNeutrino().CCNC();
	_fNuVtxX = MCTruthVector[0]->GetNeutrino().Nu().Vx();
	_fNuVtxY = MCTruthVector[0]->GetNeutrino().Nu().Vy();
	_fNuVtxZ = MCTruthVector[0]->GetNeutrino().Nu().Vz();
	_fNuEnergy =  MCTruthVector[0]->GetNeutrino().Nu().E();
	_fNuMode = MCTruthVector[0]->GetNeutrino().Mode();    
      }//neutrino set

      if(std::abs(_fNuPDG) == 14 && _fNuCCNC == 0){nnumucc++;}
      if(std::abs(_fNuMode) == 5){nnuescatter++;}
      ntotal++;
  
    }//fIsBNBnuCos

    //////////// DM TRUTH INFO //////////////
    if(fIsDMe){
    
      for(int i = 0; i < MCTruthVector[0]->NParticles(); i++){
	int pdgcode = MCTruthVector[0]->GetParticle(i).PdgCode();
	double vx = MCTruthVector[0]->GetParticle(i).Vx();
	double vy = MCTruthVector[0]->GetParticle(i).Vy();
	double vz = MCTruthVector[0]->GetParticle(i).Vz();
	double endx = MCTruthVector[0]->GetParticle(i).EndX();
	double endy = MCTruthVector[0]->GetParticle(i).EndY();
	double endz = MCTruthVector[0]->GetParticle(i).EndZ();
	double px = MCTruthVector[0]->GetParticle(i).Px();
	double py = MCTruthVector[0]->GetParticle(i).Py();
	double pz = MCTruthVector[0]->GetParticle(i).Pz();
	double p = MCTruthVector[0]->GetParticle(i).P();
	double pe = MCTruthVector[0]->GetParticle(i).E();
	double pt = MCTruthVector[0]->GetParticle(i).Pt();

	if(pdgcode == 9999){

	  _fDMPDG = pdgcode;
	  _fDMVx = vx;
	  _fDMVy = vy;
	  _fDMVz = vz;
	  _fDMEndX = endx;
	  _fDMEndY = endy;
	  _fDMEndZ = endz;
	  _fDMPx = px;
	  _fDMPy = py;
	  _fDMPz = pz;
	  _fDME = pe;
	  _fDMP = p;
	  _fDMPt = pt;
	
	}//DM particle
      
      }//mctruth loop

    }//fIsDMe

  }
  
  ////// ALL MC PARTICLES ////////

  int ndmelectrons = 0;
  double costhetadmelectron = -999;
  _fNMCParticles = MCParticleVector.size();
  //_fNTruthCosmics = CosmicTruthVector.size();
  for(auto const & mcp : MCParticleVector){
    int pdgcode = mcp->PdgCode();
    int trackid = mcp->TrackId();
    int statuscode = mcp->StatusCode();
    int mother = mcp->Mother();
    int numberdaughters = mcp->NumberDaughters();
    std::string process = mcp->Process();
    double vx = mcp->Vx();
    double vy =mcp->Vy();
    double vz =mcp->Vz();
    double t = mcp->T();
    double endx =mcp->EndX();
    double endy =mcp->EndY();
    double endz =mcp->EndZ();
    double endt =mcp->EndT();
    double px =mcp->Px();
    double py =mcp->Py();
    double pz =mcp->Pz();
    double p =mcp->P();
    double pe =mcp->E();
    double pt =mcp->Pt();
    double mass = mcp->Mass();

    if(fIsDMe){
      if(process == "primary" && std::abs(pdgcode)==11  && (vx >= -200.0 && vx <= 200.0) && (vy >= -200.0 && vy <= 200.0) && (vz >= 0.0 && vz <= 500.0)){
	ndmelectrons++;
	if(p != 0){
	  costhetadmelectron = pz/p;
	}
	std::cout<<"Primary electron in TPC with costheta "<<costhetadmelectron<<std::endl;
      }
    }
    if(process == "primary" && (vx >= -200.0 && vx <= 200.0) && (vy >= -200.0 && vy <= 200.0) && (vz >= 0.0 && vz <= 500.0)){

      if(p != 0){
	costhetadmelectron = pz/p;
      }

    }
    _fMCcostheta.push_back(costhetadmelectron);

    _fMCParticlePdgCode.push_back(pdgcode);
    _fMCParticleTrackId.push_back(trackid);
    _fMCParticleStatusCode.push_back(statuscode);
    _fMCParticleMother.push_back(mother);
    _fMCParticleNumberDaughters.push_back(numberdaughters);
    _fMCParticleProcess.push_back(process);
    _fMCParticleVx.push_back(vx);
    _fMCParticleVy.push_back(vy);
    _fMCParticleVz.push_back(vz);
    _fMCParticleT.push_back(t);
    _fMCParticleEndX.push_back(endx);
    _fMCParticleEndY.push_back(endy);
    _fMCParticleEndZ.push_back(endz);
    _fMCParticleEndT.push_back(endt);
    _fMCParticlePx.push_back(px);
    _fMCParticlePy.push_back(py);
    _fMCParticlePz.push_back(pz);
    _fMCParticleP.push_back(p);
    _fMCParticleE.push_back(pe);
    _fMCParticlePt.push_back(pt);
    _fMCParticleM.push_back(mass);
  }//mcparticle loop

  //std::cout<<"NUMBER PRIMARY ELECTRONS INSIDE TPC = "<<ndmelectrons<<std::endl;

  ///////////////////////////////////////
  ////////// RECO INFORMATION ///////////
  ///////////////////////////////////////

  ////////////////////////////// Number of objects /////////////////////////////////////
  
  _fNTracks = TrackVector.size();
  _fNShowers = ShowerVector.size();
  _fNVertices = VertexVector.size();
  _fNClusters = ClusterVector.size();
  _fNSlices = SliceVector.size();
  _fNPFParticles = PFParticleVector.size();
  int nhitsu = 0;
  int nhitsv = 0;
  int nhitsy = 0;
  int nclustersu = 0;
  int nclustersv = 0;
  int nclustersy = 0;
  for(auto const & hit : HitVector){
    int plane = hit->View();
    if(plane == 0){nhitsu++;}
    if(plane == 1){nhitsv++;}
    if(plane == 2){nhitsy++;}
  }
  for(auto const & cluster : ClusterVector){
    int plane = cluster->View();
    if(plane == 0){nclustersu++;}
    if(plane == 1){nclustersv++;}
    if(plane == 2){nclustersy++;}
  }
  _fNHitsU = nhitsu;
  _fNHitsV = nhitsv;
  _fNHitsY = nhitsy;
  _fNClustersU = nclustersu;
  _fNClustersV = nclustersv;
  _fNClustersY = nclustersy;

  
  
  ////////////////////////////// SLICE INFORMATION /////////////////////////////////////
  int nslicecosmic = 0;
  int nslicepdg11 = 0;
  int nslicepdg12 = 0;
  int nslicepdg14 = 0;
  int nslicepdgother = 0;
  
  for(auto const & slice : SliceVector){
    int slicepdg = -9999;
    int slicenpfparticles = 0;
    int slicentracks = 0;
    int slicenshowers = 0;
    int slicenclusters = 0;
    int slicenclustersu = 0;
    int slicenclustersv = 0;
    int slicenclustersy = 0;
    int slicenhitsu = 0;
    int slicenhitsv = 0;
    int slicenhitsy = 0;
    double slicenuscore = -9999;
    double slicefmscore = -9999;
    double slicefmpe = -9999;
    double slicefmtime = -9999;
    double slicecrttrackscore = -9999;
    double slicecrthitscore = -9999;
    double slicecrttracktime = -9999;
    double slicecrthittime = -9999;
    float slicecrumbsscore = -99999;
    float slicetpc_CRFracHitsInLongestTrack = -9999;
    float slicetpc_CRLongestTrackDeflection = -9999;
    float slicetpc_CRLongestTrackDirY = -9999;
    int slicetpc_CRNHitsMax = -9999;
    float slicetpc_NuEigenRatioInSphere = -9999;
    int slicetpc_NuNFinalStatePfos = -9999;
    int slicetpc_NuNHitsTotal = -9999;
    int slicetpc_NuNSpacePointsInSphere = -9999;
    float slicetpc_NuVertexY = -9999;
    float slicetpc_NuWeightedDirZ = -9999;
    float slicetpc_StoppingChi2CosmicRatio = -9999;
    float slicepds_FMTotalScore = -9999;
    float slicepds_FMPE = -9999;
    float slicepds_FMTime = -9999;
    float slicecrt_TrackScore = -9999;
    float slicecrt_HitScore = -9999;
    float slicecrt_TrackTime = -9999;
    float slicecrt_HitTime = -9999;
    

    //CRUMBS VARIABLES
    int ncrumbs = 0;
    for(auto const & crumb : fmslicecrumbs.at(slice.key())){
      ncrumbs++;
      slicecrumbsscore = crumb->score;
      slicetpc_CRFracHitsInLongestTrack = crumb->tpc_CRFracHitsInLongestTrack;
      slicetpc_CRLongestTrackDeflection = crumb->tpc_CRLongestTrackDeflection;
      slicetpc_CRLongestTrackDirY = crumb->tpc_CRLongestTrackDirY;
      slicetpc_CRNHitsMax = crumb->tpc_CRNHitsMax;
      slicetpc_NuEigenRatioInSphere = crumb->tpc_NuEigenRatioInSphere;
      slicetpc_NuNFinalStatePfos = crumb->tpc_NuNFinalStatePfos;
      slicetpc_NuNHitsTotal = crumb->tpc_NuNHitsTotal;
      slicetpc_NuNSpacePointsInSphere = crumb->tpc_NuNSpacePointsInSphere;
      slicetpc_NuVertexY = crumb->tpc_NuVertexY;
      slicetpc_NuWeightedDirZ = crumb->tpc_NuWeightedDirZ;
      slicetpc_StoppingChi2CosmicRatio = crumb->tpc_StoppingChi2CosmicRatio;
      slicepds_FMTotalScore = crumb->pds_FMTotalScore;
      slicepds_FMPE = crumb->pds_FMPE;
      slicepds_FMTime = crumb->pds_FMTime;
      slicecrt_TrackScore = crumb->crt_TrackScore;
      slicecrt_HitScore = crumb->crt_SPScore;
      slicecrt_TrackTime = crumb->crt_TrackTime;
      slicecrt_HitTime = crumb->crt_SPTime;
    }//crumbs
    
    //ALL PFPARTICLES
    for(auto const & pfp : fmslicepfp.at(slice.key())){
      slicenpfparticles++;
      int nshowersforpfp = 0;
      int nclustersforpfp = 0;
      int ntracksforpfp = 0;
      for(auto const & track : fmpfptrack.at(pfp.key())){
	slicentracks++;
	ntracksforpfp++;
	std::cout<<track->Length()<<std::endl;
      }//associated tracks
      for(auto const & cluster : fmpfpcluster.at(pfp.key())){
  	slicenclusters++;
  	nclustersforpfp++;
  	if(cluster->View() == 0){slicenclustersu++;}
  	if(cluster->View() == 1){slicenclustersv++;}
  	if(cluster->View() == 2){slicenclustersy++;}
      }//associated clusters
      for(auto const & shower : ShowerVector){
	bool matched = false;
	for(auto const & pfp2 : fmshowerpfp.at(shower.key())){if(pfp2->Self() == pfp->Self()){matched = true;}}
	if(matched == true){nshowersforpfp++;slicenshowers++;}
      }//associated showers

      //PRIMARY PFPARTICLE IN SLICE
      if(pfp->IsPrimary() == false) continue;
      slicepdg = pfp->PdgCode();
      if(std::abs(pfp->PdgCode()) == 13){nslicecosmic++;}
      if(std::abs(pfp->PdgCode()) == 11){nslicepdg11++;}
      if(std::abs(pfp->PdgCode()) == 12){nslicepdg12++;}
      if(std::abs(pfp->PdgCode()) == 14){nslicepdg14++;}
      if(std::abs(pfp->PdgCode()) != 11 && std::abs(pfp->PdgCode()) != 13 && std::abs(pfp->PdgCode()) != 12 && std::abs(pfp->PdgCode()) != 14){nslicepdgother++;}

      //Pandora Nu Score
      const auto associatedMetaData = nupfPartToMetaDataAssoc.at(pfp.key());
      if(associatedMetaData.size() == 1){
	const auto metaMap = associatedMetaData.at(0)->GetPropertiesMap();
	const auto nuscoreMap = metaMap.find("NuScore");
	slicenuscore = nuscoreMap->second;
      }//metadata

      //Flash Score
      
      const std::vector<art::Ptr<sbn::SimpleFlashMatch> > pfpFlashMatchVector = nupfPartToFlashAssoc.at(pfp.key());
      /*
      const art::Ptr<sbn::SimpleFlashMatch> flashmatch = pfpFlashMatchVector.front();
      slicefmscore = flashmatch->score.total;
      slicefmpe = flashmatch->light.pe;
      slicefmtime = std::max(flashmatch->time, -100.);
      */
      //CRT Score
      slicecrttrackscore = std::numeric_limits<float>::max();
      slicecrthitscore = std::numeric_limits<float>::max();
      for(auto const & track : fmpfptrack.at(pfp.key())){
	for(auto const & t0 : fmtrackcrttrackt0.at(track.key())){
	  if(t0->TriggerConfidence() < slicecrttrackscore){slicecrttrackscore = t0->TriggerConfidence();slicecrttracktime = t0->Time() * 1e-3;}	  
	}//CRT Track T0s
	for(auto const & t0 : fmtrackcrthitt0.at(track.key())){
	  if(t0->TriggerConfidence() < slicecrthitscore){slicecrthitscore = t0->TriggerConfidence();slicecrthittime = t0->Time() * 1e-3;}	  
	}//CRT Hit T0s
      }//associated tracks
 
    }//associated pfp loop

    for(auto const & hit : fmslicehit.at(slice.key())){
      if(hit->View() == 0){slicenhitsu++;}
      if(hit->View() == 1){slicenhitsv++;}
      if(hit->View() == 2){slicenhitsy++;}
    }//associated hit loop

    _fSlicePdgCode.push_back(slicepdg);
    _fSliceNPFParticles.push_back(slicenpfparticles);
    _fSliceNTracks.push_back(slicentracks);
    _fSliceNShowers.push_back(slicenshowers);
    _fSliceNClusters.push_back(slicenclusters);
    _fSliceNClustersU.push_back(slicenclustersu);
    _fSliceNClustersV.push_back(slicenclustersv);
    _fSliceNClustersY.push_back(slicenclustersy);
    _fSliceNHitsU.push_back(slicenhitsu);
    _fSliceNHitsV.push_back(slicenhitsv);
    _fSliceNHitsY.push_back(slicenhitsy);
    _fSliceNuScore.push_back(slicenuscore);
    _fSliceFMScore.push_back(slicefmscore);
    _fSliceFMPE.push_back(slicefmpe);
    _fSliceFMTime.push_back(slicefmtime);
    _fSliceCRTTrackScore.push_back(slicecrttrackscore);
    _fSliceCRTTrackTime.push_back(slicecrttracktime);
    _fSliceCRTHitScore.push_back(slicecrthitscore);
    _fSliceCRTHitTime.push_back(slicecrthittime);
    
    _fSliceCrumbsScore.push_back(slicecrumbsscore);
    _ftpc_CRFracHitsInLongestTrack.push_back(slicetpc_CRFracHitsInLongestTrack);
    _ftpc_CRLongestTrackDeflection.push_back(slicetpc_CRLongestTrackDeflection);
    _ftpc_CRLongestTrackDirY.push_back(slicetpc_CRLongestTrackDirY);
    _ftpc_CRNHitsMax.push_back(slicetpc_CRNHitsMax);
    _ftpc_NuEigenRatioInSphere.push_back(slicetpc_NuEigenRatioInSphere);
    _ftpc_NuNFinalStatePfos.push_back(slicetpc_NuNFinalStatePfos);
    _ftpc_NuNHitsTotal.push_back(slicetpc_NuNHitsTotal);
    _ftpc_NuNSpacePointsInSphere.push_back(slicetpc_NuNSpacePointsInSphere);
    _ftpc_NuVertexY.push_back(slicetpc_NuVertexY);
    _ftpc_NuWeightedDirZ.push_back(slicetpc_NuWeightedDirZ);
    _ftpc_StoppingChi2CosmicRatio.push_back(slicetpc_StoppingChi2CosmicRatio);
    _fpds_FMTotalScore.push_back(slicepds_FMTotalScore);
    _fpds_FMPE.push_back(slicepds_FMPE);
    _fpds_FMTime.push_back(slicepds_FMTime);
    _fcrt_TrackScore.push_back(slicecrt_TrackScore);
    _fcrt_HitScore.push_back(slicecrt_HitScore);
    _fcrt_TrackTime.push_back(slicecrt_TrackTime);
    _fcrt_HitTime.push_back(slicecrt_HitTime);
    
  }//slice loop
  _fNSlicesCosmic = nslicecosmic;
  _fNSlicesPdgCode11 = nslicepdg11;
  _fNSlicesPdgCode12 = nslicepdg12;
  _fNSlicesPdgCode14 = nslicepdg14;
  _fNSlicesPdgCodeOther = nslicepdgother;


  ////////////////////////////// HIT INFORMATION /////////////////////////////////////
  for(auto const & hit : HitVector){
    const geo::WireID::PlaneID_t plane = hit->WireID().Plane;
    const geo::WireID::CryostatID_t cryostat = hit->WireID().Cryostat;
    const geo::WireID::TPCID_t tpc = hit->WireID().TPC;
    const geo::WireID::WireID_t wire = hit->WireID().Wire;
    double integral = hit->Integral();
    double summedadc = hit->SummedADC();
    double amplitude = hit->PeakAmplitude();
    double time = hit->PeakTime();
    double rms = hit->RMS();
    double starttick = hit->StartTick();
    double endtick = hit->EndTick();
    _fHitPlane.push_back(plane);
    _fHitCryostat.push_back(cryostat);
    _fHitTPC.push_back(tpc);
    _fHitWire.push_back(wire);
    _fHitIntegral.push_back(integral);
    _fHitSummedADC.push_back(summedadc);
    _fHitPeakAmplitude.push_back(amplitude);
    _fHitPeakTime.push_back(time);
    _fHitRMS.push_back(rms);
    _fHitStartTick.push_back(starttick);
    _fHitEndTick.push_back(endtick);    
  }//hit loop

  ////////////////////////////// CLUSTER INFORMATION /////////////////////////////////////
  for(auto const & cluster : ClusterVector){
    int plane = cluster->View();
    int nhits = cluster->NHits();
    double integral = cluster->Integral();
    double summedadc = cluster->SummedADC();
    int startwire = cluster->StartWire();
    int endwire = cluster->EndWire();
    double starttick = cluster->StartTick();
    double endtick = cluster->EndTick();
    _fClusterPlane.push_back(plane);
    _fClusterNHits.push_back(nhits);
    _fClusterIntegral.push_back(integral);
    _fClusterSummedADC.push_back(summedadc);
    _fClusterStartWire.push_back(startwire);
    _fClusterEndWire.push_back(endwire);
    _fClusterStartTick.push_back(starttick);
    _fClusterEndTick.push_back(endtick);
  }//cluster loop

  ////////////////////////////// VERTEX INFORMATION /////////////////////////////////////

  for(auto const & vertex : VertexVector){

    int id = vertex->ID();
    double x = vertex->position().X();
    double y = vertex->position().Y();
    double z = vertex->position().Z();
    
    _fVertexID.push_back(id);
    _fVertexX.push_back(x);
    _fVertexY.push_back(y);
    _fVertexZ.push_back(z);

  }

  ////////////////////////////// SHOWER INFORMATION /////////////////////////////////////
  for(auto const & shower : ShowerVector){
    int id = shower->ID();
    double dirx = shower->Direction().X();
    double diry = shower->Direction().Y();
    double dirz = shower->Direction().Z();
    double startx = shower->ShowerStart().X();
    double starty = shower->ShowerStart().Y();
    double startz = shower->ShowerStart().Z();
    int bestplane = shower->best_plane();
    double length = shower->Length();
    double openangle = shower->OpenAngle();
    double energy = (showerEnergy(2, fmshowerhit.at(shower.key())));
    _fShowerID.push_back(id);
    _fShowerDirX.push_back(dirx);
    _fShowerDirY.push_back(diry);
    _fShowerDirZ.push_back(dirz);
    _fShowerStartX.push_back(startx);
    _fShowerStartY.push_back(starty);
    _fShowerStartZ.push_back(startz);
    _fShowerBestPlane.push_back(bestplane);
    _fShowerLength.push_back(length);
    _fShowerOpenAngle.push_back(openangle);
    _fShowerEnergy.push_back(energy);
  }//shower loop

  ////////////////////////////// TRACK INFORMATION /////////////////////////////////////
  for(auto const & track : TrackVector){
    double vertexx = track->Vertex().X();
    double vertexy = track->Vertex().Y();
    double vertexz = track->Vertex().Z();
    double endx = track->End().X();
    double endy = track->End().Y();
    double endz = track->End().Z();
    double vertexdirx = track->VertexDirection().X();
    double vertexdiry = track->VertexDirection().Y();
    double vertexdirz = track->VertexDirection().Z();
    double enddirx= track->EndDirection().X();
    double enddiry = track->EndDirection().Y();
    double enddirz = track->EndDirection().Z();
    double length = track->Length();
    int id = track->ParticleId();
    double theta = track->Theta();
    double phi = track->Phi();
    double energy = (showerEnergy(2, fmtrackhit.at(track.key())));
    _fTrackVertexX.push_back(vertexx);
    _fTrackVertexY.push_back(vertexy);
    _fTrackVertexZ.push_back(vertexz);
    _fTrackEndX.push_back(endx);
    _fTrackEndY.push_back(endy);
    _fTrackEndZ.push_back(endz);
    _fTrackVertexDirX.push_back(vertexdirx);
    _fTrackVertexDirY.push_back(vertexdiry);
    _fTrackVertexDirZ.push_back(vertexdirz);
    _fTrackEndDirX.push_back(enddirx);
    _fTrackEndDirY.push_back(enddiry);
    _fTrackEndDirZ.push_back(enddirz);
    _fTrackLength.push_back(length);
    _fTrackParticleId.push_back(id);
    _fTrackTheta.push_back(theta);
    _fTrackPhi.push_back(phi);
    _fTrackEnergy.push_back(energy);
  }//track loop

  
  //////////// FILL EVENT TREE /////////
  _eventtree->Fill();

}//analyze

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// void DMTree::GetMaps(art::Event const& e, std::map<int, int> &trackIDToGenMap, std::map<int, std::string> &genTypeMap){

//   unsigned nNu(0), nCos(0);

//   if(fProcessNeutrinos)
//     {
//       art::Handle<std::vector<simb::MCTruth> > handleMCTruthNu;
//       e.getByLabel(fGeneratorModuleLabel, handleMCTruthNu);
//       art::FindManyP<simb::MCParticle> truthNuMCPAssn(handleMCTruthNu,e,fMCParticleModuleLabel);

//       for (unsigned int i = 0; i < handleMCTruthNu->size(); ++i){
// 	const art::Ptr<simb::MCTruth> mcTruth(handleMCTruthNu, i);
// 	const simb::MCParticle nu = mcTruth->GetNeutrino().Nu();

// 	if(!fTpcGeo.InVolume(nu))
// 	  genTypeMap[i] = "DirtNu";
// 	else
// 	  genTypeMap[i] = "Nu";
    
// 	const std::vector<art::Ptr<simb::MCParticle> > particles = truthNuMCPAssn.at(mcTruth.key());
    
// 	for (auto const& particle : particles)
// 	  {
// 	    trackIDToGenMap[particle->TrackId()] = i;
// 	  }
// 	++nNu;
//       }
//     }

//   if(fProcessCosmics)
//     {
//       art::Handle<std::vector<simb::MCTruth> > handleMCTruthCosmic;
//       e.getByLabel(fCosmicModuleLabel, handleMCTruthCosmic);

//       art::FindManyP<simb::MCParticle> truthCosmicMCPAssn(handleMCTruthCosmic,e,fMCParticleModuleLabel);

//       for (unsigned int i = 0; i < handleMCTruthCosmic->size(); ++i){
// 	const art::Ptr<simb::MCTruth> mcTruth(handleMCTruthCosmic, i);

// 	genTypeMap[i + nNu] = "Cosmic";
    
// 	const std::vector<art::Ptr<simb::MCParticle> > particles = truthCosmicMCPAssn.at(mcTruth.key());
    
// 	for (auto const& particle : particles)
// 	  {
// 	    trackIDToGenMap[particle->TrackId()] = i + nNu;
// 	  }
// 	++nCos;
//       }
//     }
  
//   eventID = e.event();
//   subRunID = e.subRun();
//   runID = e.run();
  
// }//GetMaps


// void DMTree::GetTruthMatching(art::Event const& e, const std::vector<art::Ptr<recob::Hit> > &sliceHits, const std::vector<art::Ptr<recob::Hit> > &allHits, std::map<int, int> &trackIDToGenMap, int &matchedID, double &purity, double &completeness){
  
//   std::map<int, int> sliceHitMap;
//   std::map<int, float> slicePurityMap;

//   auto clockData = art::ServiceHandle<detinfo::DetectorClocksService>()->DataFor(e);

//   for(auto const& hit : sliceHits){
//     ++sliceHitMap[trackIDToGenMap[TruthMatchUtils::TrueParticleID(clockData,hit,true)]];
//   }
    
//   for(auto const& [id, nHits] : sliceHitMap){
//     slicePurityMap[id] = (float)nHits/(float)sliceHits.size();
//   }

//   for(auto const& [id, pur] : slicePurityMap){
//     if(pur > purity){
//       matchedID = id;
//       purity = pur;
//     }
//   }

//   int totalTrueHits(0);

//   for (auto const& hit : allHits){
//     if(trackIDToGenMap[TruthMatchUtils::TrueParticleID(clockData,hit,true)] == matchedID){
//       ++totalTrueHits;
//     }
//   }
  
//   if(totalTrueHits == 0){
//     completeness = 0;
//   }
//   else{
//     completeness = sliceHitMap[matchedID] / (float) totalTrueHits;
//   }
// }//GetTruthMatching

////////////////

double DMTree::showerEnergy(int plane, std::vector<art::Ptr<recob::Hit>> hits){
  double energy = 0.;
  //Calibration: converting charge to energy
  //Hit energy = hit integral [ADC] * gain [e-/ADC] * work function [MeV/e] * 1/recombination factor
  double work_function = 23.6e-6;
  double recombination_factor = 0.71;
  double overlay_gain[3];
  overlay_gain[0] = 245;
  overlay_gain[1] = 252;
  overlay_gain[2] = 237.6;
  //if(hits.size() == 0){std::cout<<"SHOWER HAS NO HITS!"<<std::endl;}
    for(auto const& ihit : hits){
    auto hitplane = ihit->View();
    if(hitplane != plane) continue; //get hits from current plane
    double current_hit_charge = ihit->Integral(); //ADC
    double current_hit_energy = -9999.;
    current_hit_energy = current_hit_charge*overlay_gain[hitplane]*work_function*(1/recombination_factor);
    energy += current_hit_energy;
  }//shower hits
  return energy;
}//showerEnergy

 double DMTree::recoEnergy(detinfo::DetectorClocksData const& clockData, detinfo::DetectorPropertiesData const& detProp,const std::vector<art::Ptr<recob::Hit>>& hits,const geo::PlaneID::PlaneID_t plane)const{

   double totalCharge = 0;
   double totalEnergy = 0;
   double correctedtotalCharge = 0;
   double nElectrons = 0;
   //std::vector<double> CalAreaConstants = [ 0.773887e-2 , 1.78186e-2 ];

   for (auto const& hit : hits){
     totalCharge += hit->Integral()*LifetimeCorrection(clockData, detProp, hit->PeakTime(),0); //lifetime (assuming lifetime form 0) ?
   }
   correctedtotalCharge = totalCharge/0.71;//recombination ?
   nElectrons = correctedtotalCharge/1.78186e-2; //hit integral to number of electrons (not sure which CalAreaConstants to use) ?
   totalEnergy = (nElectrons / util::kGeVToElectrons) * 1000; // energy in MeV
   return totalEnergy;
 }

 double DMTree::LifetimeCorrection(detinfo::DetectorClocksData const& clock_data,detinfo::DetectorPropertiesData const& det_prop,double const time,double const T0) const{
   float const t = time - trigger_offset(clock_data);
   double const timetick = sampling_rate(clock_data) * 1.e-3; // time sample in microsec
   double const adjusted_time = t * timetick - T0 * 1e-3;     //  (in microsec)
   double const tau = det_prop.ElectronLifetime();
   return exp(adjusted_time / tau);
 }

void DMTree::endSubRun(art::SubRun const & sr) {

  art::Handle <sumdata::POTSummary> potsum_h ;
  if(sr.getByLabel("generator",potsum_h)){
    _pot = potsum_h->totpot;
  }

  //std::cout<<"POT "<<_pot<<std::endl;
  
  // if(!fIsMC && !fIsDirt){
  //   _run = sr.run();
  //   _subRun = sr.subRun();
  // }
  _tree->Fill();

  
}//endSubRun


void DMTree::endJob(){

  mf::LogVerbatim("DMTree")<< "DMTree finished job";

  //std::cout<<"NumuCC = "<<nnumucc<<" Total = "<<ntotal<<" nue scatter = "<<nnuescatter<<std::endl;
   
   
}//endJob


std::map<art::Ptr<simb::MCTruth>, int> DMTree::GetTruthHitMap(
		       const detinfo::DetectorClocksData &clockData, 
		       const sim::ParticleList &trueParticlesMap,
		       const std::map<int, art::Ptr<simb::MCTruth>> &particleTruthMap,
		       const std::vector<art::Ptr<recob::Hit>> &allHits) {

  // Create a map of true particles to number of hits
  std::map<int, int> trueParticleHits;
  //std::cout<<"test"<<std::endl;
  //std::cout<<"hits size: "<<allHits.size()<<std::endl;
  for (const auto &hit : allHits) {
    int trackID     = 0;
    float hitEnergy = 0;
    
    // For each hit, chose the particle that contributed the most energy
    std::vector<sim::TrackIDE> trackIDEs = bt_serv->HitToTrackIDEs(clockData, hit);
    //std::cout<<"ide size: "<<trackIDEs.size()<<std::endl;
    for (const auto &ide : trackIDEs) {
      //std::cout<<"ide: "<<ide.energy<<std::endl;
      if (ide.energy > hitEnergy) {
        hitEnergy = ide.energy;
        trackID   = std::abs(ide.trackID);
      } // ide.energy > hitEnergy
    } // ide: trackIDEs
    ++trueParticleHits[trackID];
    //std::cout<<"hitEnergy: "<<hitEnergy<<std::endl;
    //std::cout<<"trackID: "<<trackID<<std::endl;
  } // hit: allHits

  // Roll up the particles in their slices
  std::map<art::Ptr<simb::MCTruth>, int> truthHitMap;
  for (const auto &[trueParticle, truth] : particleTruthMap) {
    truthHitMap[truth] += trueParticleHits[trueParticle];
  } // [trueParticle, truth]: particleTruthMap

  return truthHitMap;
} // GetTruthHitMap

DEFINE_ART_MODULE(DMTree)
