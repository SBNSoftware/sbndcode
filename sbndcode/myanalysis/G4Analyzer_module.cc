////////////////////////////////////////////////////////////////////////
// Class:       G4Analyzer
// Module Type: analyzer
// File:        G4Analyzer_module.cc
//
// Generated at Fri Jun 25 19:32:19 2021 by Ivan Lepetic using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "art_root_io/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"

#include "TTree.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCFlux.h"

class G4Analyzer;

class G4Analyzer : public art::EDAnalyzer {
public:
  explicit G4Analyzer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  G4Analyzer(G4Analyzer const &) = delete;
  G4Analyzer(G4Analyzer &&) = delete;
  G4Analyzer & operator = (G4Analyzer const &) = delete;
  G4Analyzer & operator = (G4Analyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p);
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.

  std::string m_neutrinoproducer;
  std::string m_mcparticle_producer;

  TTree *fEventTree;

  std::vector<Int_t> nuPDG_truth;
  std::vector<float> enu_truth;
  std::vector<float> nuvtxx_truth;
  std::vector<float> nuvtxy_truth;
  std::vector<float> nuvtxz_truth;
/*  std::vector<float> nupx_truth;
  std::vector<float> nupy_truth;
  std::vector<float> nupz_truth;*/

  UInt_t fNumMCParticles = 0;
  std::vector<Int_t> fTrackId;
  std::vector<Int_t> fMother;
  std::vector<Int_t> fNumberDaughters;
  std::vector<Int_t> fpdg;
  std::vector<float> fEng;
  std::vector<float> fStartPointx;
  std::vector<float> fStartPointy;
  std::vector<float> fStartPointz;
/*  std::vector<float> fEndPointx;
  std::vector<float> fEndPointy;
  std::vector<float> fEndPointz;
  std::vector<float> fTime;
  std::vector<float> fPx;
  std::vector<float> fPy;
  std::vector<float> fPz;*/
  std::vector<std::string> fprocess;


};


G4Analyzer::G4Analyzer(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

  art::ServiceHandle<art::TFileService> tfs;
      this->reconfigure(p);

      fEventTree = tfs->make<TTree>("Event", "Event Tree");
      fEventTree->Branch("NuPDG", "std::vector<Int_t>", &nuPDG_truth);
      fEventTree->Branch("NuEnergy", "std::vector<float>", &enu_truth);
      fEventTree->Branch("VertexX", "std::vector<float>", &nuvtxx_truth);
      fEventTree->Branch("VertexY", "std::vector<float>", &nuvtxy_truth);
      fEventTree->Branch("VertexZ", "std::vector<float>", &nuvtxz_truth);
  /*    fEventTree->Branch("NuPx", "std::vector<float>", &nupx_truth);
      fEventTree->Branch("NuPy", "std::vector<float>", &nupy_truth);
      fEventTree->Branch("NuPz", "std::vector<float>", &nupz_truth);
*/
      fEventTree->Branch("TrackId", "std::vector<Int_t>", &fTrackId);
      fEventTree->Branch("Mother", "std::vector<Int_t>", &fMother);
      fEventTree->Branch("NumberDaughters", "std::vector<Int_t>", &fNumberDaughters);
      fEventTree->Branch("pdg", "std::vector<Int_t>", &fpdg);
      fEventTree->Branch("Eng", "std::vector<float>", &fEng);
      fEventTree->Branch("StartPointx", "std::vector<float>", &fStartPointx);
      fEventTree->Branch("StartPointy", "std::vector<float>", &fStartPointy);
      fEventTree->Branch("StartPointz", "std::vector<float>", &fStartPointz);
  /*    fEventTree->Branch("EndPointx", "std::vector<float>", &fEndPointx);
      fEventTree->Branch("EndPointy", "std::vector<float>", &fEndPointy);
      fEventTree->Branch("EndPointz", "std::vector<float>", &fEndPointz);*/
  //    fEventTree->Branch("Time", "std::vector<float>", &fTime);
  /*    fEventTree->Branch("Px", "std::vector<float>", &fPx);
      fEventTree->Branch("Py", "std::vector<float>", &fPy);
      fEventTree->Branch("Pz", "std::vector<float>", &fPz);*/
      fEventTree->Branch("process", "std::vector<std::string>", &fprocess);



}

void G4Analyzer::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  nuPDG_truth.clear();
  enu_truth.clear();
  nuvtxx_truth.clear();
  nuvtxy_truth.clear();
  nuvtxz_truth.clear();
/*  nupx_truth.clear();
  nupy_truth.clear();
  nupz_truth.clear();*/

  fNumMCParticles = 0;
  fTrackId.clear();
  fMother.clear();
  fNumberDaughters.clear();
  fpdg.clear();
  fEng.clear();
  fStartPointx.clear();
  fStartPointy.clear();
  fStartPointz.clear();
/*  fEndPointx.clear();
  fEndPointy.clear();
  fEndPointz.clear();
  fPx.clear();
  fPy.clear();
  fPz.clear();
  fTime.clear();*/
  fprocess.clear();

  art::Handle< std::vector<simb::MCTruth> > mctruthListHandle;
   std::vector<art::Ptr<simb::MCTruth> > mclist;
   e.getByLabel(m_neutrinoproducer,mctruthListHandle);
     art::fill_ptr_vector(mclist, mctruthListHandle);

   std::cout << "Neutrino producer: " << m_neutrinoproducer << std::endl;

     for (unsigned int i_mctruth = 0; i_mctruth < mclist.size(); i_mctruth++){
             //fetch an mctruth
             art::Ptr<simb::MCTruth> curr_mctruth = mclist[i_mctruth];
             //Check if it's a neutrino
             if (!curr_mctruth->NeutrinoSet()) continue;

            nuPDG_truth.push_back(curr_mctruth->GetNeutrino().Nu().PdgCode());
            enu_truth.push_back(curr_mctruth->GetNeutrino().Nu().E());
            nuvtxx_truth.push_back(curr_mctruth->GetNeutrino().Nu().Vx());
            nuvtxy_truth.push_back(curr_mctruth->GetNeutrino().Nu().Vy());
            nuvtxz_truth.push_back(curr_mctruth->GetNeutrino().Nu().Vz());
          /*  nupx_truth.push_back(curr_mctruth->GetNeutrino().Nu().Px());
            nupy_truth.push_back(curr_mctruth->GetNeutrino().Nu().Py());
            nupz_truth.push_back(curr_mctruth->GetNeutrino().Nu().Pz());*/
      }

      typedef art::Handle<std::vector<simb::MCParticle>> MCParticleHandle;
      MCParticleHandle mcparticles_in_event;
      e.getByLabel(m_mcparticle_producer, mcparticles_in_event);

      fNumMCParticles = mcparticles_in_event->size();
      for (UInt_t ii = 0; ii < fNumMCParticles; ii++)
      {
        const art::Ptr<simb::MCParticle> this_mcparticle(mcparticles_in_event, ii);


        fTrackId.push_back(this_mcparticle->TrackId());
        fMother.push_back(this_mcparticle->Mother());
        fNumberDaughters.push_back(this_mcparticle->NumberDaughters());
        fpdg.push_back(this_mcparticle->PdgCode());
        fEng.push_back(this_mcparticle->E());
        fStartPointx.push_back(this_mcparticle->Vx());
        fStartPointy.push_back(this_mcparticle->Vy());
        fStartPointz.push_back(this_mcparticle->Vz());
      /*  fEndPointx.push_back(this_mcparticle->EndX());
        fEndPointy.push_back(this_mcparticle->EndY());
        fEndPointz.push_back(this_mcparticle->EndZ());
        fPx.push_back(this_mcparticle->Px());
        fPy.push_back(this_mcparticle->Py());
        fPz.push_back(this_mcparticle->Pz());
        fTime.push_back(this_mcparticle->T());*/
        fprocess.push_back(this_mcparticle->Process());
      }

      fEventTree->Fill();

}

void G4Analyzer::beginJob()
{
  // Implementation of optional member function here.
}

void G4Analyzer::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void G4Analyzer::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void G4Analyzer::endJob()
{
  // Implementation of optional member function here.
}

void G4Analyzer::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void G4Analyzer::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void G4Analyzer::reconfigure(fhicl::ParameterSet const & p)
{
    m_neutrinoproducer = p.get<std::string>("neutrinoproducer", "generator");
    m_mcparticle_producer = p.get<std::string>("mcparticle_producer", "largeant");
  // Implementation of optional member function here.
}

void G4Analyzer::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void G4Analyzer::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void G4Analyzer::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void G4Analyzer::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(G4Analyzer)
