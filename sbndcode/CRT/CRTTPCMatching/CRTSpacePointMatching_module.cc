/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTSpacePointMatching
/// Module Type: producer
/// File:        CRTSpacePointMatching_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/// Modified from CRTT0Matching by Thomas Warburton.
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbnobj/SBND/CRT/CRTSpacePoint.hh"
#include "sbnobj/SBND/CRT/CRTCluster.hh"
#include "sbndcode/CRT/CRTTPCMatching/CRTSpacePointMatchAlg.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "art_root_io/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larsim/MCCheater/BackTrackerService.h"

// ROOT
#include "TVector3.h"


namespace sbnd {
  
  class CRTSpacePointMatching : public art::EDProducer {
  public:

    explicit CRTSpacePointMatching(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTSpacePointMatching(CRTSpacePointMatching const &) = delete;
    CRTSpacePointMatching(CRTSpacePointMatching &&) = delete;
    CRTSpacePointMatching & operator = (CRTSpacePointMatching const &) = delete; 
    CRTSpacePointMatching & operator = (CRTSpacePointMatching &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

    // Params got from fcl file.......
    art::InputTag fTpcTrackModuleLabel; ///< name of track producer
    art::InputTag fCrtSpacePointModuleLabel;   ///< name of crt producer

    CRTSpacePointMatchAlg matchAlg;

  }; // class CRTSpacePointMatching


  CRTSpacePointMatching::CRTSpacePointMatching(fhicl::ParameterSet const & p)
    : EDProducer(p), matchAlg(p.get<fhicl::ParameterSet>("matchAlg"))
      // Initialize member data here, if know don't want to reconfigure on the fly
  {

    // Call appropriate produces<>() functions here.
    produces< std::vector<anab::T0>                  >();
    produces< art::Assns<recob::Track , anab::T0>    >();
    produces< art::Assns<sbnd::crt::CRTSpacePoint, anab::T0> >();
    
    reconfigure(p);

  } // CRTSpacePointMatching()


  void CRTSpacePointMatching::reconfigure(fhicl::ParameterSet const & p)
  {

    fTpcTrackModuleLabel = (p.get<art::InputTag> ("TpcTrackModuleLabel"));
    fCrtSpacePointModuleLabel   = (p.get<art::InputTag> ("CrtSpacePointModuleLabel")); 

  } // CRTSpacePointMatching::reconfigure()


  void CRTSpacePointMatching::produce(art::Event & event)
  {

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<anab::T0> > T0col( new std::vector<anab::T0>);
    std::unique_ptr< art::Assns<recob::Track, anab::T0> > trackassn( new art::Assns<recob::Track, anab::T0>);
    std::unique_ptr< art::Assns <sbnd::crt::CRTSpacePoint, anab::T0> > crtspassn( new art::Assns<sbnd::crt::CRTSpacePoint, anab::T0> );

    // Retrieve CRTSpacePoint list
    art::Handle<std::vector<sbnd::crt::CRTSpacePoint>> crtListHandle;
    std::vector<art::Ptr<sbnd::crt::CRTSpacePoint>> crtList;
    if(event.getByLabel(fCrtSpacePointModuleLabel, crtListHandle))
      art::fill_ptr_vector(crtList, crtListHandle);

    std::vector<sbnd::crt::CRTSpacePoint> crtSpacePoints;
    for (auto const& crtSpacePoint : crtList){
      crtSpacePoints.push_back(*crtSpacePoint);
    }

    art::FindOneP<sbnd::crt::CRTCluster> spacePointsToCluster(crtListHandle, event, fCrtSpacePointModuleLabel);

    // Retrieve track list
    art::Handle< std::vector<recob::Track> > trackListHandle;
    std::vector<art::Ptr<recob::Track> > trackList;
    if (event.getByLabel(fTpcTrackModuleLabel,trackListHandle))
      art::fill_ptr_vector(trackList, trackListHandle);   

    mf::LogInfo("CRTSpacePointMatching")
      <<"Number of reconstructed tracks = "<<trackList.size()<<"\n"
      <<"Number of CRTSpacePoints = "<<crtList.size();
   
    if (trackListHandle.isValid() && crtListHandle.isValid() ){

      auto const detProp = art::ServiceHandle<detinfo::DetectorPropertiesService const>()->DataFor(event);
      // Loop over all the reconstructed tracks 
      for(size_t track_i = 0; track_i < trackList.size(); track_i++) {

        matchCand closest = matchAlg.GetClosestCRTSpacePoint(detProp, *trackList[track_i], crtSpacePoints, event);

        if(closest.dca >=0 ){
          mf::LogInfo("CRTSpacePointMatching")
            <<"Matched time = "<<closest.t0<<" [us] to track "<<trackList[track_i]->ID()<<" with DCA = "<<closest.dca;

          //find this CRTSpacePoint in the collection
          // note this does not work (both the loop and the assoc !!)
          unsigned CRTSpacePointIndex = std::numeric_limits<unsigned>::max();
          for (int ic=0; ic<(int)crtList.size(); ++ic){
            if (*crtList[ic]==closest.thisSP)
              CRTSpacePointIndex=ic;
          }

          const art::Ptr<sbnd::crt::CRTCluster> &cluster = spacePointsToCluster.at(crtList[CRTSpacePointIndex].key());

          T0col->push_back(anab::T0(closest.t0*1e3, trackList[track_i]->ID(),  cluster->Tagger(), (int)closest.extrapLen, closest.dca));
          util::CreateAssn(*this, event, *T0col, trackList[track_i], *trackassn);

          if (CRTSpacePointIndex != std::numeric_limits<unsigned>::max())
            util::CreateAssn(*this, event, *T0col, crtList[CRTSpacePointIndex], *crtspassn);

        } // DCA check

      } // Loop over tracks  

    } // Validity check

    event.put(std::move(T0col));
    event.put(std::move(trackassn));
    event.put(std::move(crtspassn));

  } // CRTSpacePointMatching::produce()

  DEFINE_ART_MODULE(CRTSpacePointMatching)

} // sbnd namespace
