/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTTrackMatching
/// Module Type: producer
/// File:        CRTTrackMatching_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbnobj/SBND/CRT/CRTTrack.hh"
#include "sbndcode/CRT/CRTTPCMatching/CRTTrackMatchAlg.h"
#include "sbndcode/Geometry/GeometryWrappers/TPCGeoAlg.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "art_root_io/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"

// ROOT
#include "TVector3.h"

namespace {
  // Local namespace for local functions

}

namespace sbnd {
  
  class CRTTrackMatching : public art::EDProducer {
  public:

    explicit CRTTrackMatching(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTTrackMatching(CRTTrackMatching const &) = delete;
    CRTTrackMatching(CRTTrackMatching &&) = delete;
    CRTTrackMatching & operator = (CRTTrackMatching const &) = delete; 
    CRTTrackMatching & operator = (CRTTrackMatching &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

    // Params got from fcl file.......
    art::InputTag fTpcTrackModuleLabel; ///< name of track producer
    art::InputTag fCrtTrackModuleLabel; ///< name of crt producer

    CRTTrackMatchAlg trackAlg;
    TPCGeoAlg fTpcGeo;

  }; // class CRTTrackMatching


  CRTTrackMatching::CRTTrackMatching(fhicl::ParameterSet const & p)
    : EDProducer(p), trackAlg(p.get<fhicl::ParameterSet>("CrtTrackAlg"))
      // Initialize member data here, if know don't want to reconfigure on the fly
  {

    // Call appropriate produces<>() functions here.
    produces< std::vector<anab::T0> >();
    produces< art::Assns<recob::Track , anab::T0> >();
    produces< art::Assns<sbnd::crt::CRTTrack , anab::T0> >();
    
    reconfigure(p);

  } // CRTTrackMatching()


  void CRTTrackMatching::reconfigure(fhicl::ParameterSet const & p)
  {

    fTpcTrackModuleLabel = (p.get<art::InputTag> ("TpcTrackModuleLabel"));
    fCrtTrackModuleLabel = (p.get<art::InputTag> ("CrtTrackModuleLabel")); 

  } // CRTTrackMatching::reconfigure()


  void CRTTrackMatching::produce(art::Event & event)
  {

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<anab::T0> > T0col( new std::vector<anab::T0>);
    std::unique_ptr< art::Assns<recob::Track, anab::T0> > tpcassn( new art::Assns<recob::Track, anab::T0>);
    std::unique_ptr< art::Assns<sbnd::crt::CRTTrack, anab::T0> > crtassn( new art::Assns<sbnd::crt::CRTTrack, anab::T0>);

    // Get TPC tracks
    art::Handle< std::vector<recob::Track> > tpcTrackListHandle;
    std::vector<art::Ptr<recob::Track> > tpcTrackList;
    if (event.getByLabel(fTpcTrackModuleLabel, tpcTrackListHandle))
      art::fill_ptr_vector(tpcTrackList, tpcTrackListHandle);   

    // Get track to hit associations
    //art::FindManyP<recob::Hit> findManyHits(tpcTrackListHandle, event, fTpcTrackModuleLabel);

    // Get CRT tracks
    art::Handle< std::vector<sbnd::crt::CRTTrack> > crtTrackListHandle;
    std::vector<art::Ptr<sbnd::crt::CRTTrack> > crtTrackList;
    if (event.getByLabel(fCrtTrackModuleLabel, crtTrackListHandle))
      art::fill_ptr_vector(crtTrackList, crtTrackListHandle);

    std::vector<sbnd::crt::CRTTrack> crtTracks;
    for(auto const& crtTrack : crtTrackList){
      crtTracks.push_back(*crtTrack);
    }

    auto const detProp = art::ServiceHandle<detinfo::DetectorPropertiesService const>()->DataFor(event);

    // Validity check
    if (tpcTrackListHandle.isValid() && crtTrackListHandle.isValid() ){

      mf::LogInfo("CRTTrackMatching")
        <<"Number of TPC tracks = "<<tpcTrackList.size()<<"\n"
        <<"Number of CRT tracks = "<<crtTrackList.size();
      for (size_t tpc_i = 0; tpc_i < tpcTrackList.size(); tpc_i++){

        std::pair<int,double> matchedResult = trackAlg.GetMatchedCRTTrackIdAndScore(detProp,
                                                                                    *tpcTrackList[tpc_i], crtTracks, event);
        int matchedID = matchedResult.first;
        double matchedScore = matchedResult.second;
        
        if(matchedID != -99999){
          double crtTime = crtTracks.at(matchedID).Time(); // [ns]
          T0col->push_back(anab::T0(crtTime, 0, tpcTrackList[tpc_i]->ID(), (*T0col).size(), matchedScore)); 
          util::CreateAssn(*this, event, *T0col, tpcTrackList[tpc_i], *tpcassn);
          util::CreateAssn(*this, event, *T0col, crtTrackList[matchedID], *crtassn);
        }
      }
    } // Validity check
   
    event.put(std::move(T0col));
    event.put(std::move(tpcassn));
    event.put(std::move(crtassn));
    
  } // CRTTrackMatching::produce()
  
  DEFINE_ART_MODULE(CRTTrackMatching)

} // sbnd namespace

